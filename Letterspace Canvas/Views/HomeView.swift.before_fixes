import SwiftUI
import PDFKit
import AppKit
import UniformTypeIdentifiers
import CoreGraphics

// Move column definition to a separate struct
struct ListColumn: Identifiable, Hashable {
    let id: String
    let title: String
    var width: CGFloat {
        // Minimum widths for each column type
        switch id {
        case "name":
            return 350  // Name column width
        case "series":
            return 200  // Fixed width for series
        case "location":
            return 180  // Fixed width for location (changed from 200)
        case "date", "createdDate", "presentedDate":
            return 150  // Fixed width for date columns
        default:
            return calculateWidth(for: [])
        }
    }
    
    // Calculate width based on content
    func calculateWidth(for documents: [Letterspace_CanvasDocument]) -> CGFloat {
        // Base padding
        let padding: CGFloat = 40
        let minWidth: CGFloat = 150
        
        // For series, location, and date columns, return fixed width
        if id == "series" {
            return 200
        }
        if id == "location" {
            return 180  // Changed from 200
        }
        if id == "date" || id == "createdDate" || id == "presentedDate" {
            return 150
        }
        
        let maxWidth: CGFloat = documents.reduce(CGFloat(title.count * 10)) { maxWidth, doc in
            let content: String = {
                switch id {
                default:
                    return ""
                }
            }()
            
            // More accurate text width estimation
            let contentWidth = CGFloat(content.count * 10)
            return max(maxWidth, contentWidth)
        }
        
        return max(minWidth, maxWidth + padding)
    }
    
    static let name = ListColumn(id: "name", title: "Name")
    static let series = ListColumn(id: "series", title: "Series")
    static let location = ListColumn(id: "location", title: "Location")
    static let date = ListColumn(id: "date", title: "Modified")
    static let createdDate = ListColumn(id: "createdDate", title: "Created")
    static let presentedDate = ListColumn(id: "presentedDate", title: "Presented On")
    
    static let allColumns: [ListColumn] = [
        .name, .series, .location, .date, .createdDate, .presentedDate
    ]
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    static func == (lhs: ListColumn, rhs: ListColumn) -> Bool {
        lhs.id == rhs.id
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
}

// Add this extension to make column width calculation easier
extension ListColumn {
    func width(for documents: [Letterspace_CanvasDocument]) -> CGFloat {
        switch id {
        case "name":
            return 350  // Changed from 300 to 350
        default:
            return calculateWidth(for: documents)
        }
    }
}

struct PinnedDocumentButton: View {
    let document: Letterspace_CanvasDocument
    let action: () -> Void
    @Binding var pinnedDocuments: Set<String>
    @Environment(\.colorScheme) var colorScheme
    @Environment(\.themeColors) var theme
    @State private var isHovering = false
    
    var body: some View {
        Button(action: action) {
            HStack(spacing: 10) {
                // Green dot for pinned
                Circle()
                    .fill(Color.green)
                    .frame(width: 8, height: 8)
                Text(document.title.isEmpty ? "Untitled" : document.title)
                    .font(.custom("InterTight-Regular", size: 14))
                    .tracking(0.3)
                    .foregroundStyle(theme.primary)
                    .lineLimit(1)
                Spacer()
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 8)
            .padding(.horizontal, 10)
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(isHovering ? 
                        (colorScheme == .dark ? Color(.sRGB, white: 0.25) : Color(.sRGB, white: 0.97)) : 
                        .clear)
            )
            .contentShape(Rectangle())
        }
        .buttonStyle(.plain)
        .onHover { hovering in
            isHovering = hovering
        }
        .padding(.horizontal, 4)
        .contextMenu {
            Button(action: {
                pinnedDocuments.remove(document.id)
                UserDefaults.standard.set(Array(pinnedDocuments), forKey: "PinnedDocuments")
                NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
            }) {
                Label("Unpin", systemImage: "pin.slash")
            }
        }
    }
}

struct WIPDocumentButton: View {
    let document: Letterspace_CanvasDocument
    let action: () -> Void
    @Environment(\.colorScheme) var colorScheme
    @Environment(\.themeColors) var theme
    @State private var isHovering = false
    
    var body: some View {
        Button(action: action) {
            HStack(spacing: 10) {
                // Orange dot for WIP
                Circle()
                    .fill(Color.orange)
                    .frame(width: 8, height: 8)
                Text(document.title.isEmpty ? "Untitled" : document.title)
                    .font(.custom("InterTight-Regular", size: 14))
                    .tracking(0.3)
                    .foregroundStyle(theme.primary)
                    .lineLimit(1)
                Spacer()
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 8)
            .padding(.horizontal, 10)
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(isHovering ? 
                        (colorScheme == .dark ? Color(.sRGB, white: 0.25) : Color(.sRGB, white: 0.97)) : 
                        .clear)
            )
            .contentShape(Rectangle())
        }
        .buttonStyle(.plain)
        .onHover { hovering in
            isHovering = hovering
        }
        .padding(.horizontal, 4)
    }
}

// Update the DateFilterType enum
enum DateFilterType {
    case modified
    
    var title: String {
        return "Modified"
    }
}

// Add this new view before DocumentTable
struct MultiSelectionActionBar: View {
    let selectedCount: Int
    let onPin: () -> Void
    let onWIP: () -> Void
    let onDelete: () -> Void
    @Environment(\.themeColors) var theme
    @Environment(\.colorScheme) var colorScheme
    @State private var isPinHovering = false
    @State private var isWIPHovering = false
    @State private var isDeleteHovering = false
    
    var body: some View {
        HStack(spacing: 16) {
            Text("\(selectedCount) selected")
                .font(.system(size: 13))
                .foregroundStyle(theme.primary)
            
            Divider()
                .frame(height: 20)
            
            Button(action: onPin) {
                HStack(spacing: 4) {
                    Image(systemName: "pin.fill")
                    Text("Pin")
                }
                .font(.system(size: 13))
                .padding(.horizontal, 6)
                .padding(.vertical, 4)
                .background(
                    RoundedRectangle(cornerRadius: 4)
                        .fill(isPinHovering ? 
                            (colorScheme == .dark ? Color.white.opacity(0.1) : Color.black.opacity(0.05)) : 
                            .clear)
                )
            }
            .buttonStyle(.plain)
            .foregroundStyle(theme.primary)
            .onHover { hovering in
                isPinHovering = hovering
            }
            
            Button(action: onWIP) {
                HStack(spacing: 4) {
                    Image(systemName: "clock.fill")
                    Text("WIP")
                }
                .font(.system(size: 13))
                .padding(.horizontal, 6)
                .padding(.vertical, 4)
                .background(
                    RoundedRectangle(cornerRadius: 4)
                        .fill(isWIPHovering ? 
                            (colorScheme == .dark ? Color.white.opacity(0.1) : Color.black.opacity(0.05)) : 
                            .clear)
                )
            }
            .buttonStyle(.plain)
            .foregroundStyle(theme.primary)
            .onHover { hovering in
                isWIPHovering = hovering
            }
            
            Button(action: onDelete) {
                HStack(spacing: 4) {
                    Image(systemName: "trash.fill")
                    Text("Delete")
                        .fixedSize(horizontal: true, vertical: false) // Ensure text doesn't get truncated
                }
                .font(.system(size: 13))
                .padding(.horizontal, 8) // Increased from 6 to 8
                .padding(.vertical, 4)
                .background(
                    RoundedRectangle(cornerRadius: 4)
                        .fill(isDeleteHovering ? 
                            (colorScheme == .dark ? Color.white.opacity(0.1) : Color.black.opacity(0.05)) : 
                            .clear)
                )
            }
            .buttonStyle(.plain)
            .foregroundStyle(.red)
            .onHover { hovering in
                isDeleteHovering = hovering
            }
        }
        .padding(.horizontal, 28) // Increased from 24 to 28
        .padding(.vertical, 12)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(colorScheme == .dark ? Color(.sRGB, white: 0.2) : .white)
                .shadow(
                    color: Color.black.opacity(colorScheme == .dark ? 0.5 : 0.15),
                    radius: 15,
                    x: 0,
                    y: 5
                )
        )
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(Color(.separatorColor).opacity(0.1), lineWidth: 0.5)
        )
        .frame(minWidth: 240) // Add minimum width to ensure all content fits
    }
}

struct DashboardView: View {
    @Binding var document: Letterspace_CanvasDocument
    @Environment(\.themeColors) var theme
    @Environment(\.colorScheme) var colorScheme
    @State private var selectedColumn: ListColumn = .name
    @State private var sortAscending = true
    @State private var dateFilterType: DateFilterType = .modified
    @State private var scrollOffset: CGFloat = 0
    @Namespace private var scrollSpace
    @State private var documents: [Letterspace_CanvasDocument] = []
    @State private var selectedDocuments: Set<String> = []
    @State private var pinnedDocuments: Set<String> = []
    @State private var isSelectionMode: Bool = false
    @State private var pinnedScrollOffset: CGFloat = 0
    @State private var wipScrollOffset: CGFloat = 0
    @State private var calendarScrollOffset: CGFloat = 0
    @State private var shouldFlashPinnedScroll = false
    @State private var wipDocuments: Set<String> = []
    @State private var visibleColumns: Set<String> = Set(ListColumn.allColumns.map { $0.id })
    @State private var calendarDocuments: Set<String> = []
    @Binding var sidebarMode: RightSidebar.SidebarMode
    @Binding var isRightSidebarVisible: Bool
    @State private var folders: [Folder] = []
    @State private var selectedTags: Set<String> = []
    @State private var showTagManager = false
    @State private var isHoveringInfo = false
    @State private var hoveredTag: String? = nil
    @StateObject private var colorManager = TagColorManager.shared
    @State private var isViewButtonHovering = false
    @State private var showDetailsCard = false
    @State private var selectedDetailsDocument: Letterspace_CanvasDocument?
    @State private var showShareSheet = false
    
    // Add these functions before the body
    private func togglePin(for docId: String) {
        if pinnedDocuments.contains(docId) {
            pinnedDocuments.remove(docId)
        } else {
            pinnedDocuments.insert(docId)
        }
        saveDocumentState()
    }
    
    private func toggleWIP(_ docId: String) {
        if wipDocuments.contains(docId) {
            wipDocuments.remove(docId)
        } else {
            wipDocuments.insert(docId)
        }
        saveDocumentState()
    }
    
    private func deleteSelectedDocuments() {
        let fileManager = FileManager.default
        let documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let appDirectory = documentsURL.appendingPathComponent("Letterspace Canvas")
        let trashURL = appDirectory.appendingPathComponent(".trash", isDirectory: true)
        
        print("Moving documents to trash at: \(trashURL.path)")
        
        // Create trash directory if it doesn't exist
        do {
            try fileManager.createDirectory(at: appDirectory, withIntermediateDirectories: true, attributes: nil)
            try fileManager.createDirectory(at: trashURL, withIntermediateDirectories: true, attributes: nil)
            print("Created or verified trash directory")
        } catch {
            print("Error creating trash directory: \(error)")
            return
        }
        
        for docId in selectedDocuments {
            if let document = documents.first(where: { $0.id == docId }) {
                let sourceURL = appDirectory.appendingPathComponent("\(document.id).canvas")
                let destinationURL = trashURL.appendingPathComponent("\(document.id).canvas")
                
                print("Moving document to trash: \(document.title) (\(document.id))")
                print("From: \(sourceURL.path)")
                print("To: \(destinationURL.path)")
                
                do {
                    // If destination file exists, remove it first
                    if fileManager.fileExists(atPath: destinationURL.path) {
                        try fileManager.removeItem(at: destinationURL)
                        print("Removed existing file at destination")
                    }
                    
                    try fileManager.moveItem(at: sourceURL, to: destinationURL)
                    
                    // Set the modification date to track when it was moved to trash
                    try fileManager.setAttributes([.modificationDate: Date()], ofItemAtPath: destinationURL.path)
                    
                    print("Successfully moved document to trash")
                } catch {
                    print("Error moving document to trash: \(error)")
                }
            }
        }
        
        selectedDocuments.removeAll()
        NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
    }
    
    private func saveDocumentState() {
        let defaults = UserDefaults.standard
        defaults.set(Array(pinnedDocuments), forKey: "PinnedDocuments")
        defaults.set(Array(wipDocuments), forKey: "WIPDocuments")
        
        // Post notification that documents have been updated
        NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
    }
    
    private func getTimeBasedGreeting() -> String {
        let hour = Calendar.current.component(.hour, from: Date())
        let firstName = UserProfileManager.shared.userProfile.firstName.isEmpty ? "Friend" : UserProfileManager.shared.userProfile.firstName
        
        let greeting: String
        if hour >= 0 && hour < 12 {
            greeting = "Good Morning,"
        } else if hour >= 12 && hour < 17 {
            greeting = "Good Afternoon,"
        } else {
            greeting = "Good Evening,"
        }
        
        return "\(greeting) \(firstName)!"
    }
    
    var body: some View {
        ZStack(alignment: .bottom) {
            GeometryReader { geometry in
                VStack(alignment: .leading, spacing: 0) {
                    Spacer().frame(minHeight: 50)
                    
                    HStack {
                        VStack(alignment: .leading, spacing: 4) {
                        Text("Dashboard")
                                .font(.system(size: 14, weight: .bold))
                                .foregroundStyle(theme.primary.opacity(0.7))
                                .padding(.bottom, 2)
                            
                            Text(getTimeBasedGreeting())
                                .font(.custom("InterTight-Regular", size: 35))
                            .tracking(0.3)
                            .foregroundStyle(theme.primary)
                        }
                        Spacer()
                    }
                    
                    Spacer().frame(minHeight: 40)
                    
                    topContainers
                    
                    
                    Spacer()
                    
                    // Fixed spacing between top containers and All Documents
                    Spacer().frame(height: 10)  // Fixed spacing of 10
                    
                    // All Documents section
                    VStack(spacing: 0) {
                        // Title with icon and tag filters on same line
                        HStack(spacing: 8) {
                            // Left side - Title
                            HStack(spacing: 8) {
                                Image(systemName: "doc.text.fill")
                                    .font(.custom("InterTight-Regular", size: 14))
                                    .foregroundStyle(theme.primary)
                                Text("All Documents")
                                    .font(.custom("InterTight-Medium", size: 16))
                                    .foregroundStyle(theme.primary)
                                Text("(\(filteredDocuments.count))")
                                    .font(.custom("InterTight-Regular", size: 14))
                                    .foregroundStyle(theme.secondary)
                                    .frame(width: 40, alignment: .leading)
                                
                                Menu {
                                    ForEach(ListColumn.allColumns) { column in
                                        if column.id != "name" { // Always show name column
                                            Toggle(column.title, isOn: Binding(
                                                get: { visibleColumns.contains(column.id) },
                                                set: { isOn in
                                                    if isOn {
                                                        visibleColumns.insert(column.id)
                                                    } else {
                                                        visibleColumns.remove(column.id)
                                                    }
                                                    // Save column preferences
                                                    UserDefaults.standard.set(Array(visibleColumns), forKey: "VisibleColumns")
                                                }
                                            ))
                                        }
                                    }
                                } label: {
                                    HStack(spacing: 4) {
                                        Text("My List View")
                                            .font(.system(size: 13))
                                            .foregroundStyle(colorScheme == .dark ? .white : Color(.sRGB, white: 0.3))
                                        Image(systemName: "line.3.horizontal.decrease")
                                            .font(.system(size: 10))
                                            .foregroundStyle(colorScheme == .dark ? .white : Color(.sRGB, white: 0.3))
                                    }
                                    .padding(.horizontal, 8)
                                    .padding(.vertical, 4)
                                    .background(
                                        RoundedRectangle(cornerRadius: 6)
                                            .fill(colorScheme == .dark ? 
                                                Color(.sRGB, white: isViewButtonHovering ? 0.25 : 0.22) : 
                                                Color(.sRGB, white: isViewButtonHovering ? 0.92 : 0.95))
                                    )
                                    .contentShape(Rectangle())
                                }
                                .buttonStyle(.plain)
                                .onHover { hovering in
                                    withAnimation(.easeInOut(duration: 0.2)) {
                                        isViewButtonHovering = hovering
                                        if hovering {
                                            NSCursor.pointingHand.push()
                                        } else {
                                            NSCursor.pop()
                                        }
                                    }
                                }
                                .fixedSize()
                            }
                            
                            if !allTags.isEmpty {
                                // Spacer to push tags to the right a bit
                                Spacer().frame(width: 32)
                                
                                // Tags section
                                HStack(spacing: 8) {
                                    Text("Tags")
                                        .font(.custom("InterTight-Medium", size: 13))
                                        .tracking(0.3)
                                        .foregroundStyle(theme.primary)
                                    
                                    Button(action: {
                                        showTagManager = true
                                    }) {
                                        Image(systemName: "info.circle")
                                            .font(.system(size: 13))
                                            .foregroundStyle(theme.primary)
                                    }
                                    .buttonStyle(.plain)
                                    .opacity(isHoveringInfo ? 0.6 : 1.0)
                                    .onHover { hovering in
                                        isHoveringInfo = hovering
                                    }
                                    .popover(isPresented: $showTagManager, arrowEdge: .bottom) {
                                        TagManager(allTags: allTags)
                                            .frame(width: 280)
                                            .background(Color(.windowBackgroundColor))
                                    }
                                    
                                    // Tag filters
                                    ScrollView(.horizontal, showsIndicators: false) {
                                        HStack(spacing: 10) {
                                            ForEach(allTags, id: \.self) { tag in
                                                Button(action: {
                                                    if selectedTags.contains(tag) {
                                                        selectedTags.remove(tag)
                                                    } else {
                                                        selectedTags.insert(tag)
                                                    }
                                                }) {
                                                    Text(tag)
                                                        .font(.custom("InterTight-Medium", size: 10))
                                                        .tracking(0.7)
                                                        .foregroundStyle(tagColor(for: tag))
                                                        .padding(.horizontal, 10)
                                                        .padding(.vertical, 3)
                                                        .background(
                                                            RoundedRectangle(cornerRadius: 6)
                                                                .stroke(tagColor(for: tag), lineWidth: 1.5)
                                                                .background(
                                                                    RoundedRectangle(cornerRadius: 6)
                                                                        .fill(Color(colorScheme == .dark ? .black : .white).opacity(0.1))
                                                                )
                                                        )
                                                }
                                                .buttonStyle(.plain)
                                                .opacity(selectedTags.isEmpty || selectedTags.contains(tag) ? 1.0 : 0.3)
                                                .onHover { isHovered in
                                                    withAnimation(.easeOut(duration: 0.15)) {
                                                        hoveredTag = isHovered ? tag : nil
                                                    }
                                                }
                                            }
                                        }
                                        .padding(.vertical, 2)
                                        .padding(.horizontal, 2)
                                    }
                                }
                            }
                            
                            Spacer()
                        }
                        .padding(.horizontal, 24)
                        .padding(.top, 24)
                        .padding(.bottom, 16)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        
                        DocumentTable(
                            documents: Binding(
                                get: { filteredDocuments },
                                set: { documents = $0 }
                            ),
                            selectedDocuments: $selectedDocuments,
                            isSelectionMode: isSelectionMode,
                            pinnedDocuments: pinnedDocuments,
                            wipDocuments: wipDocuments,
                            calendarDocuments: calendarDocuments,
                            visibleColumns: visibleColumns,
                            dateFilterType: dateFilterType,
                            onPin: togglePin,
                            onWIP: toggleWIP,
                            onCalendar: toggleCalendar,
                            onOpen: { doc in
                                self.document = doc
                                self.sidebarMode = .details
                                self.isRightSidebarVisible = true
                            },
                            onShowDetails: showDetails,
                            onDelete: { docIds in
                                selectedDocuments = Set(docIds)
                                deleteSelectedDocuments()
                            }
                        )
                        .frame(maxHeight: .infinity)
                    }
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(colorScheme == .dark ? Color(.sRGB, white: 0.12) : .white)
                    )
                    .clipShape(RoundedRectangle(cornerRadius: 12))
                    .shadow(
                        color: colorScheme == .dark ? .black.opacity(0.17) : .black.opacity(0.07),  // Updated from 0.15/0.05 to 0.17/0.07
                        radius: 8,
                        x: 0,
                        y: 1
                    )
                    .frame(minWidth: 1000, maxWidth: 1600)
                    .frame(height: 400)  // Reduced from 425
                    .padding(.top, 6)
                    .padding(.bottom, 6)  // Reduced bottom padding
                }
                .frame(maxWidth: .infinity, alignment: .center)
                .frame(maxHeight: .infinity, alignment: .bottom)  // Changed to align content to bottom
                .scrollDismissesKeyboard(.immediately)
                .coordinateSpace(name: "dashboard")
                .padding(.horizontal, 20)  // Reduced horizontal padding for content containers
                .padding(.top, 0)  // Removed top padding to allow Spacer to control spacing
                .padding(.bottom, 24)  // Added bottom padding to ensure space at the bottom

                .onAppear {
                    loadFolders()
                    
                    // Load pinned documents
                    if let pinnedArray = UserDefaults.standard.array(forKey: "PinnedDocuments") as? [String] {
                        pinnedDocuments = Set(pinnedArray)
                    }
                    
                    // Load WIP documents
                    if let wipArray = UserDefaults.standard.array(forKey: "WIPDocuments") as? [String] {
                        wipDocuments = Set(wipArray)
                    }
                    
                    // Load calendar documents
                    if let calendarArray = UserDefaults.standard.array(forKey: "CalendarDocuments") as? [String] {
                        calendarDocuments = Set(calendarArray)
                    }
                    
                    // Load visible columns
                    if let savedColumns = UserDefaults.standard.array(forKey: "VisibleColumns") as? [String] {
                        visibleColumns = Set(savedColumns)
                    }
                    
                    loadDocuments()
                }
                .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("DocumentListDidUpdate"))) { _ in
                    loadDocuments()
                }
                .overlay(
                    Group {
                        if selectedDocuments.count >= 2 {
                            VStack {
                                Spacer()
                                MultiSelectionActionBar(
                                    selectedCount: selectedDocuments.count,
                                    onPin: {
                                        // Check if all selected documents are already pinned
                                        let allPinned = selectedDocuments.allSatisfy { pinnedDocuments.contains($0) }
                                        
                                        if allPinned {
                                            // If all are pinned, unpin all of them
                                            for docId in selectedDocuments {
                                                pinnedDocuments.remove(docId)
                                            }
                                        } else {
                                            // Otherwise, pin any that aren't pinned yet
                                            for docId in selectedDocuments {
                                                pinnedDocuments.insert(docId)
                                            }
                                        }
                                        saveDocumentState()
                                    },
                                    onWIP: {
                                        // Check if all selected documents are already WIP
                                        let allWIP = selectedDocuments.allSatisfy { wipDocuments.contains($0) }
                                        
                                        if allWIP {
                                            // If all are WIP, remove all of them
                                            for docId in selectedDocuments {
                                                wipDocuments.remove(docId)
                                            }
                                        } else {
                                            // Otherwise, add any that aren't WIP yet
                                            for docId in selectedDocuments {
                                                wipDocuments.insert(docId)
                                            }
                                        }
                                        saveDocumentState()
                                    },
                                    onDelete: deleteSelectedDocuments
                                )
                                .padding(.bottom, 24)
                                .transition(
                                    .asymmetric(
                                        insertion: .scale(scale: 0.8)
                                            .combined(with: .offset(y: 50))
                                            .combined(with: .opacity),
                                        removal: .scale(scale: 0.8)
                                            .combined(with: .offset(y: 50))
                                            .combined(with: .opacity)
                                    )
                                )
                            }
                        }
                    }
                    .animation(.spring(response: 0.3, dampingFraction: 0.7, blendDuration: 0), value: selectedDocuments.count > 1)
                )
            }
            .animation(.spring(response: 0.3, dampingFraction: 0.7, blendDuration: 0), value: selectedDocuments.count > 1)
            .sheet(isPresented: $showDetailsCard) {
                DocumentDetailsCard(document: .constant(document))
                    .frame(width: 400, height: 600)
                    .interactiveDismissDisabled(true)
            }
            .animation(.easeInOut(duration: 0.2), value: showDetailsCard)
        }
    }
    
    private var topContainers: some View {
        VStack(alignment: .leading, spacing: 24) {
            HStack(spacing: 24) {
                PinnedSection(
                    documents: documents,
                    pinnedDocuments: pinnedDocuments,
                    document: $document,
                    sidebarMode: $sidebarMode,
                    isRightSidebarVisible: $isRightSidebarVisible
                )
                .frame(maxWidth: .infinity)
                
                WIPSection(
                    documents: documents,
                    wipDocuments: wipDocuments,
                    document: $document,
                    sidebarMode: $sidebarMode,
                    isRightSidebarVisible: $isRightSidebarVisible
                )
                .frame(maxWidth: .infinity)
                
                CalendarSection(
                    documents: documents,
                    calendarDocuments: calendarDocuments
                )
                .frame(maxWidth: .infinity)
            }
            .frame(minWidth: 1000, maxWidth: 1600)
            .frame(height: 228)  // Fixed height for the sections
            .padding(.vertical, 6)  // Added vertical padding
        }
        .frame(maxWidth: .infinity, alignment: .center)
        .frame(height: 240)  // Fixed height for the container
    }
    
    private func loadDocuments() {
        guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            print("Could not find documents directory")
            return
        }
        
        let appDirectory = documentsPath.appendingPathComponent("Letterspace Canvas")
        
        do {
            // Create app directory if it doesn't exist
            try FileManager.default.createDirectory(at: appDirectory, withIntermediateDirectories: true, attributes: nil)
            print("📁 Created or verified app directory at: \(appDirectory.path)")
            
            let fileURLs = try FileManager.default.contentsOfDirectory(at: appDirectory, includingPropertiesForKeys: nil)
                .filter { $0.pathExtension == "canvas" }
            
            let loadedDocuments = fileURLs.compactMap { url -> Letterspace_CanvasDocument? in
                do {
                    let data = try Data(contentsOf: url)
                    let doc = try JSONDecoder().decode(Letterspace_CanvasDocument.self, from: data)
                    return doc
                } catch {
                    print("Error loading document at \(url): \(error)")
                    return nil
                }
            }
            
            // Sort documents based on selected column and direction
            documents = sortDocuments(loadedDocuments)
            
        } catch {
            print("Error loading documents: \(error)")
            documents = []
        }
    }
    
    private func sortDocuments(_ docs: [Letterspace_CanvasDocument]) -> [Letterspace_CanvasDocument] {
        docs.sorted { (doc1: Letterspace_CanvasDocument, doc2: Letterspace_CanvasDocument) -> Bool in
            let result: Bool
            
            if selectedColumn == .name {
                let title1 = doc1.title.isEmpty ? "Untitled" : doc1.title
                let title2 = doc2.title.isEmpty ? "Untitled" : doc2.title
                result = title1.localizedCompare(title2) == .orderedAscending
            }
            else if selectedColumn == .date {
                switch dateFilterType {
                case .modified:
                    result = doc1.modifiedAt < doc2.modifiedAt
                }
            }
            else if selectedColumn == .series {
                // For now, just compare if series exists
                if doc1.series == nil && doc2.series == nil {
                    result = false
                } else if doc1.series == nil {
                    result = false
                } else if doc2.series == nil {
                    result = true
                } else {
                    result = doc1.series!.name.localizedCompare(doc2.series!.name) == .orderedAscending
                }
            }
            else if selectedColumn == .location {
                // Sort by location if available
                let loc1 = doc1.variations.first?.location ?? ""
                let loc2 = doc2.variations.first?.location ?? ""
                result = loc1.localizedCompare(loc2) == .orderedAscending
            }
            else if selectedColumn == .createdDate {
                result = doc1.createdAt < doc2.createdAt
            }
            else if selectedColumn == .presentedDate {
                let date1 = doc1.variations.first?.datePresented
                let date2 = doc2.variations.first?.datePresented
                if date1 == nil && date2 == nil {
                    result = false
                } else if date1 == nil {
                    result = false
                } else if date2 == nil {
                    result = true
                } else {
                    result = date1! < date2!
                }
            }
            else {
                // Default to sorting by modified date
                result = doc1.modifiedAt < doc2.modifiedAt
            }
            
            return sortAscending ? result : !result
        }
    }
    
    private func toggleCalendar(_ documentId: String) {
        // Find the document first
        guard let index = documents.firstIndex(where: { $0.id == documentId }) else { return }
        var updatedDoc = documents[index]
        
        if calendarDocuments.contains(documentId) {
            // Remove from calendar
            calendarDocuments.remove(documentId)
            
            // Clear scheduling information
            if var firstVariation = updatedDoc.variations.first {
                firstVariation.datePresented = nil
                firstVariation.serviceTime = nil
                firstVariation.notes = nil
                updatedDoc.variations[0] = firstVariation
            }
        } else {
            // Add to calendar
            calendarDocuments.insert(documentId)
        }
        
        // Update the document in our array
        documents[index] = updatedDoc
        
        // Save the document
        updatedDoc.save()
        
        // Save calendar documents state
        UserDefaults.standard.set(Array(calendarDocuments), forKey: "CalendarDocuments")
        UserDefaults.standard.synchronize()
        
        // Force UI update
        DispatchQueue.main.async {
            // Post notification to update views
            NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
        }
    }
    
    private func saveFolders() {
        let foldersToSave = folders.map { folder in
            // Create a copy without isEditing state for storage
            Folder(id: folder.id, name: folder.name, isEditing: false)
        }
        if let encoded = try? JSONEncoder().encode(foldersToSave) {
            UserDefaults.standard.set(encoded, forKey: "SavedFolders")
        }
    }
    
    private func loadFolders() {
        if let savedData = UserDefaults.standard.data(forKey: "SavedFolders"),
           let decodedFolders = try? JSONDecoder().decode([Folder].self, from: savedData) {
            // Restore folders with isEditing set to false
            folders = decodedFolders.map { Folder(id: $0.id, name: $0.name, isEditing: false) }
            saveFolders() // Save the default folders
        } else {
            // Initialize with default folders if none are saved
            folders = [
                Folder(id: UUID(), name: "Sermons", isEditing: false),
                Folder(id: UUID(), name: "Bible Studies", isEditing: false),
                Folder(id: UUID(), name: "Notes", isEditing: false),
                Folder(id: UUID(), name: "Archive", isEditing: false)
            ]
            saveFolders() // Save the default folders
        }
    }
    
    private var allTags: [String] {
        var tags: Set<String> = []
        for document in documents {
            if let documentTags = document.tags {
                tags.formUnion(documentTags)
            }
        }
        return Array(tags).sorted()
    }
    
    private var filteredDocuments: [Letterspace_CanvasDocument] {
        if selectedTags.isEmpty {
            return documents
        }
        return documents.filter { doc in
            guard let docTags = doc.tags else { return false }
            return !selectedTags.isDisjoint(with: docTags)
        }
    }
    
    private func tagColor(for tag: String) -> Color {
        return colorManager.color(for: tag)
    }

    // Add this function to handle showing details
    private func showDetails(for document: Letterspace_CanvasDocument) {
        // Set the document first
        selectedDetailsDocument = document
        // Then show the sheet with a slight delay to ensure content is ready
        DispatchQueue.main.async {
            showDetailsCard = true
        }
    }
}

// New implementation of DocumentDetailsCard
struct DocumentDetailsCard: View {
    @Environment(\.dismiss) var dismiss
    @Environment(\.colorScheme) var colorScheme
    @Environment(\.themeColors) var theme
    @Binding var document: Letterspace_CanvasDocument
    @StateObject private var colorManager = TagColorManager.shared
    @State private var title: String
    @State private var subtitle: String
    @State private var seriesName: String
    @State private var datePresented: String
    @State private var showShareSheet = false
    @State private var location: String
    @State private var tags: Set<String>
    @State private var newTag: String = ""
    @State private var isEditing = false // Changed to start in read-only mode
    @State private var isContentReady = false
    @State private var showSeriesSuggestions = false
    @State private var showLocationSuggestions = false
    @State private var showTagSuggestions = false
    @State private var recentSeries: [String] = []
    @State private var recentLocations: [String] = []
    @State private var recentTags: [String] = []
    @State private var scrollOffset: CGFloat = 0
    @State private var selectedTab: Tab = .info // Track selected tab
    @State private var summaryText: String = "" // Store the generated summary
    @State private var isGeneratingSummary: Bool = false // Track if summary is being generated
    @State private var localDocument: Letterspace_CanvasDocument // Local copy of the document
    @State private var showCopiedNotification: Bool = false // Track when to show the "Copied" notification
    
    // Define tabs
    enum Tab: String, CaseIterable {
        case info = "Info"
        case variations = "Variations" 
        case links = "Links"
        case clips = "Clips"
    }
    
    // Add documents array
    private var documents: [Letterspace_CanvasDocument] {
        // Get documents directory
        guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            print("❌ Could not access documents directory")
            return []
        }
        
        let appDirectory = documentsPath.appendingPathComponent("Letterspace Canvas")
        print("📂 Loading documents from directory: \(appDirectory.path)")
        
        do {
            // Get all canvas files
            let fileURLs = try FileManager.default.contentsOfDirectory(at: appDirectory, includingPropertiesForKeys: nil)
                .filter { $0.pathExtension == "canvas" }
            
            print("📂 Found \(fileURLs.count) canvas files")
            
            // Load all documents
            let loadedDocs = fileURLs.compactMap { url -> Letterspace_CanvasDocument? in
                do {
                    let data = try Data(contentsOf: url)
                    let doc = try JSONDecoder().decode(Letterspace_CanvasDocument.self, from: data)
                    print("📂 Loaded document: \(doc.title) (ID: \(doc.id))")
                    return doc
                } catch {
                    print("❌ Error loading document at \(url): \(error)")
                    return nil
                }
            }
            
            print("📂 Loaded \(loadedDocs.count) documents total")
            return loadedDocs
        } catch {
            print("❌ Error accessing documents directory: \(error)")
            return []
        }
    }
    
    private func loadRecentItems() {
        // Load recent series from all documents
        let allSeries = Set(documents.compactMap { $0.series?.name })
        recentSeries = Array(allSeries).sorted()
        
        // Load recent locations from all documents
        let allLocations = Set(documents.compactMap { $0.variations.first?.location }.filter { !$0.isEmpty })
        recentLocations = Array(allLocations).sorted()
        
        // Load recent tags from all documents
        let allTags = Set(documents.compactMap { $0.tags }.flatMap { $0 })
        recentTags = Array(allTags).sorted()
    }
    
    init(document: Binding<Letterspace_CanvasDocument>) {
        self._document = document
        
        // Initialize all state variables immediately
        let doc = document.wrappedValue
        self._title = State(initialValue: doc.title)
        self._subtitle = State(initialValue: doc.subtitle)
        self._seriesName = State(initialValue: doc.series?.name ?? "")
        self._location = State(initialValue: doc.variations.first?.location ?? "")
        self._tags = State(initialValue: Set(doc.tags ?? []))
        
        let dateStr: String
        if let date = doc.variations.first?.datePresented {
            let formatter = DateFormatter()
            formatter.dateFormat = "MMM d, yyyy"
            dateStr = formatter.string(from: date)
        } else {
            dateStr = ""
        }
        self._datePresented = State(initialValue: dateStr)
        
        // Load summary if it exists
        self._summaryText = State(initialValue: doc.summary ?? "")
        
        // Initialize local document copy
        self._localDocument = State(initialValue: doc)
        
        // Mark content as ready immediately
        self._isContentReady = State(initialValue: true)
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header with icons
            HStack {
                // Document Details text
                Text("Document Details")
                    .font(.system(size: 14, weight: .semibold))
                    .foregroundStyle(theme.primary)
                
                Spacer()
                
                // Edit button (moved to header)
                Button(action: {
                    isEditing.toggle()
                }) {
                    Text(isEditing ? "Done" : "Edit")
                        .font(.system(size: 14))
                        .foregroundStyle(Color.blue)
                }
                .buttonStyle(.plain)
                .padding(.trailing, 8)
                
                // Share button
                Button(action: {
                    showShareSheet = true
                }) {
                    Image(systemName: "square.and.arrow.up")
                        .font(.system(size: 16))
                        .foregroundStyle(theme.secondary)
                }
                .buttonStyle(.plain)
                .padding(.trailing, 8)
                .popover(isPresented: $showShareSheet, arrowEdge: .top) {
                    CustomShareSheet(document: document, isPresented: $showShareSheet)
                }
                
                // Close button
                Button(action: { dismiss() }) {
                    Image(systemName: "xmark")
                        .font(.system(size: 18, weight: .medium))
                        .foregroundStyle(theme.primary)
                }
                .buttonStyle(.plain)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            
            Divider()
            
            ZStack(alignment: .top) {
                // Content
                ScrollViewReader { scrollProxy in
                    ScrollView(.vertical, showsIndicators: true) {
                        GeometryReader { geometry in
                            Color.clear.preference(
                                key: ScrollOffsetPreferenceKey.self,
                                value: geometry.frame(in: .named("scrollView")).minY
                            )
                        }
                        .frame(height: 0)
                        
                        // Header Image Thumbnail (if exists)
                        Group {
                            if let headerElement = document.elements.first(where: { $0.type == .headerImage && !$0.content.isEmpty }) {
                                // New layout with header image on left, title/subtitle on right
                                HStack(alignment: .top, spacing: 16) {
                                    // Smaller header image on the left with 16:9 aspect ratio
                                HeaderImageThumbnail(imagePath: headerElement.content, documentId: document.id, document: $document)
                                        .frame(width: 160, height: 90) // 16:9 aspect ratio
                                        .cornerRadius(6)
                                        .shadow(color: Color.black.opacity(0.1), radius: 3, x: 0, y: 1)
                                        .id("headerImage")
                                    
                                    // Title & Subtitle on the right
                                    VStack(alignment: .leading, spacing: 8) {
                                        if isEditing {
                                            TextField("Title", text: $title)
                                                .font(.system(size: 24, weight: .bold))
                                                .textFieldStyle(.plain)
                                                .padding(10)
                                                .background(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97))
                                                .cornerRadius(6)
                                            
                                            TextField("Subtitle", text: $subtitle)
                                                .font(.system(size: 16))
                                                .textFieldStyle(.plain)
                                                .padding(10)
                                                .background(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97))
                                                .cornerRadius(6)
                                        } else {
                                            Text(title.isEmpty ? "Untitled" : title)
                                                .font(.system(size: 24, weight: .bold))
                                                .foregroundStyle(theme.primary)
                                                .frame(maxWidth: .infinity, alignment: .leading)
                                            
                                            if !subtitle.isEmpty {
                                                Text(subtitle)
                                                    .font(.system(size: 16))
                                                    .foregroundStyle(theme.secondary)
                                                    .frame(maxWidth: .infinity, alignment: .leading)
                                            }
                                        }
                                    }
                                    .frame(maxWidth: .infinity)
                                }
                                    .padding(.horizontal, 16)
                                    .padding(.top, 16)
                                
                                // Add extra padding here to create more breathing room
                                Spacer()
                                    .frame(height: 16)
                                
                                // AI Summary Button - more compact design
                                // Only show the button if there's no summary and we're not generating one
                                if localDocument.summary == nil && !isGeneratingSummary {
                                    HStack {
                                        Spacer()
                                        
                                        Button(action: {
                                            // Use a more direct approach without Task/MainActor
                                            isGeneratingSummary = true
                                            
                                            // Get the document content from the elements
                                            let documentContent = localDocument.elements
                                                .filter { $0.type == .textBlock }
                                                .map { $0.content }
                                                .joined(separator: "\n\n")
                                            
                                            // Create a CanvasDocument with the content
                                            let canvasDoc = CanvasDocument()
                                            canvasDoc.content = NSAttributedString(string: documentContent)
                                            canvasDoc.metadata.title = localDocument.title
                                            
                                            // Generate the summary
                                            canvasDoc.generateSummary { summary in
                                                DispatchQueue.main.async {
                                                    // Update the summary text state variable
                                                    summaryText = summary
                                                    isGeneratingSummary = false
                                                    
                                                    // Update the local document copy
                                                    localDocument.summary = summary
                                                    
                                                    // Save the document without updating the binding
                                                    var updatedDoc = document
                                                    updatedDoc.summary = summary
                                                    updatedDoc.save()
                                                }
                                            }
                                        }) {
                                            HStack(spacing: 6) {
                                                Image(systemName: "sparkles")
                                                    .font(.system(size: 12))
                                                Text("Generate Smart Summary")
                                                    .font(.system(size: 12, weight: .medium))
                                            }
                                            .padding(.vertical, 6)
                                            .padding(.horizontal, 10)
                                            .background(Color.blue.opacity(0.1))
                                            .foregroundColor(.blue)
                                            .cornerRadius(4)
                                        }
                                        .buttonStyle(.plain)
                                    }
                                    .padding(.horizontal, 16)
                                    .padding(.top, 12)
                                    .padding(.bottom, 12)
                                }
                                
                                
                                // Summary section - show when summary is available or being generated
                                if isGeneratingSummary || !summaryText.isEmpty {
                                    // Add extra padding here to create more breathing room
                                    Spacer()
                                        .frame(height: 16)
                                        
                                    VStack(alignment: .leading, spacing: 8) {
                                        HStack {
                                            Image(systemName: "sparkles")
                                                .foregroundColor(.blue)
                                            
                                            Text("Smart Summary")
                                                .font(.system(size: 14, weight: .semibold))
                                                .foregroundColor(.blue)
                                            
                                            Spacer()
                                            
                                            if !summaryText.isEmpty {
                                                HStack(spacing: 4) {
                                                    // Copy button
                                                    Button(action: {
                                                        // Copy to clipboard
                                                        let pasteboard = NSPasteboard.general
                                                        pasteboard.clearContents()
                                                        pasteboard.setString(summaryText, forType: .string)
                                                        
                                                        // Show copied notification
                                                        withAnimation(.spring(response: 0.2, dampingFraction: 0.7)) {
                                                            showCopiedNotification = true
                                                            
                                                            // Hide after 1.5 seconds
                                                            DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                                                                withAnimation(.easeOut(duration: 0.2)) {
                                                                    showCopiedNotification = false
                                                                }
                                                            }
                                                        }
                                                    }) {
                                                        Image(systemName: "doc.on.doc")
                                                            .font(.system(size: 12))
                                                            .foregroundColor(.secondary)
                                                            .frame(width: 16, height: 16)
                                                    }
                                                    .buttonStyle(.plain)
                                                    .help("Copy to Clipboard")
                                                    
                                                    // Remove button
                                                    Button(action: {
                                                        // Use a direct approach without Task/MainActor
                                                        // Clear the summary text
                                                        summaryText = ""
                                                        
                                                        // Update the local document copy
                                                        localDocument.summary = nil
                                                        
                                                        // Save the document without updating the binding
                                                        var updatedDoc = document
                                                        updatedDoc.summary = nil
                                                        updatedDoc.save()
                                                    }) {
                                                        Image(systemName: "xmark.circle.fill")
                                                            .font(.system(size: 12))
                                                            .foregroundColor(.secondary.opacity(0.7))
                                                            .frame(width: 16, height: 16)
                                                    }
                                                    .buttonStyle(.plain)
                                                    .help("Remove Summary")
                                                }
                                                .frame(width: 44, height: 20) // Fixed frame for the entire HStack
                                                .padding(.trailing, 20) // Increased trailing padding
                                                .overlay(
                                                    Group {
                                                        if showCopiedNotification {
                                                            Text("Copied")
                                                                .font(.system(size: 12, weight: .bold))
                                                                .foregroundColor(.white)
                                                                .padding(.horizontal, 8)
                                                                .padding(.vertical, 4)
                                                                .background(
                                                                    RoundedRectangle(cornerRadius: 4)
                                                                        .fill(Color.black.opacity(0.9))
                                                                )
                                                                .offset(x: -10, y: -30) // Adjusted to be more centered over the copy button
                                                                .transition(AnyTransition.asymmetric(
                                                                    insertion: .opacity.combined(with: .move(edge: .bottom)),
                                                                    removal: .opacity
                                                                ))
                                                        }
                                                    }
                                                )
                                            }
                                        }
                                        
                                        if isGeneratingSummary {
                                            HStack {
                                                ProgressView()
                                                    .scaleEffect(0.8)
                                                    .padding(.trailing, 4)
                                                Text("Generating summary...")
                                                    .font(.system(size: 13))
                                                    .foregroundColor(.secondary)
                                            }
                                            .padding(.vertical, 8)
                                        } else {
                                            // Just display the summary text without the remove button
                                            Text(summaryText.trimmingCharacters(in: .whitespacesAndNewlines))
                                                .font(.system(size: 13))
                                                .foregroundColor(.primary)
                                                .frame(maxWidth: .infinity, alignment: .leading)
                                                .padding(12)
                                                .background(
                                                    RoundedRectangle(cornerRadius: 6)
                                                        .fill(colorScheme == .dark ? 
                                                              Color(.sRGB, white: 0.22) : 
                                                              Color(.sRGB, white: 0.97))
                                                )
                                        }
                                    }
                                    .padding(.horizontal, 16)
                                    .padding(.bottom, 12) // Reduced bottom padding to remove extra space
                                }
                            } else {
                                // Add Header Image button when no image exists
                                Button(action: {
                                    addHeaderImage()
                                }) {
                                    // Create the image and text content
                                    let iconColor = colorScheme == .dark ? Color.white.opacity(0.6) : Color.black.opacity(0.5)
                                    let textColor = colorScheme == .dark ? Color.white.opacity(0.7) : Color.black.opacity(0.6)
                                    
                                    VStack(spacing: 12) {
                                        Image(systemName: "photo.badge.plus")
                                            .font(.system(size: 32))
                                            .foregroundStyle(iconColor)
                                        
                                        Text("Add Header Image")
                                            .font(.system(size: 14, weight: .medium))
                                            .foregroundStyle(textColor)
                                    }
                                    .frame(maxWidth: .infinity)
                                    .frame(height: 120)
                                    .background(AddHeaderButtonBackground(colorScheme: colorScheme))
                                }
                                .buttonStyle(.plain)
                                .padding(.horizontal, 16)
                                .padding(.top, 16)
                        
                                // Title & Subtitle without header image
                            VStack(alignment: .leading, spacing: 8) {
                                if isEditing {
                                    TextField("Title", text: $title)
                                        .font(.system(size: 24, weight: .bold))
                                        .textFieldStyle(.plain)
                                        .padding(10)
                                        .background(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97))
                                        .cornerRadius(6)
                                    
                                    TextField("Subtitle", text: $subtitle)
                                        .font(.system(size: 16))
                                        .textFieldStyle(.plain)
                                        .padding(10)
                                        .background(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97))
                                        .cornerRadius(6)
                                } else {
                                    Text(title.isEmpty ? "Untitled" : title)
                                        .font(.system(size: 24, weight: .bold))
                                        .foregroundStyle(theme.primary)
                                        .padding(.top, 8)
                                        .frame(maxWidth: .infinity, alignment: .leading)
                                    
                                    if !subtitle.isEmpty {
                                        Text(subtitle)
                                            .font(.system(size: 16))
                                            .foregroundStyle(theme.secondary)
                                            .padding(.bottom, 8)
                                            .frame(maxWidth: .infinity, alignment: .leading)
                                    }
                                }
                            }
                            .padding(.horizontal, 16)
                                .padding(.top, 8)
                            }
                        }
                        
                        VStack(spacing: 24) {
                            // Remove the duplicate title & subtitle section since we've moved it up
                            
                            // Tab Bar
                            VStack(spacing: 0) {
                                // Tab buttons
                                HStack(spacing: 0) {
                                    ForEach(Tab.allCases, id: \.self) { tab in
                                        Button(action: {
                                            withAnimation(.easeInOut(duration: 0.25)) {
                                                selectedTab = tab
                                            }
                                        }) {
                                            VStack(spacing: 8) {
                                                Text(tab.rawValue)
                                                    .font(.system(size: 14, weight: selectedTab == tab ? .semibold : .regular))
                                                    .foregroundColor(selectedTab == tab ? theme.primary : theme.secondary)
                                                    .padding(.horizontal, 12)
                                                    .padding(.vertical, 8)
                                            }
                                        }
                                        .buttonStyle(.plain)
                                        .frame(maxWidth: .infinity)
                                    }
                                }
                                
                                // Animated indicator line
                                GeometryReader { geometry in
                                    let tabWidth = geometry.size.width / CGFloat(Tab.allCases.count)
                                    let indicatorPosition = tabWidth * CGFloat(Tab.allCases.firstIndex(of: selectedTab) ?? 0)
                                    
                                    Rectangle()
                                        .fill(Color.blue)
                                        .frame(width: tabWidth, height: 2)
                                        .offset(x: indicatorPosition)
                                        .animation(.easeInOut(duration: 0.25), value: selectedTab)
                                }
                                .frame(height: 2)
                                
                                Divider()
                            }
                            
                            // Tab content
                            ZStack {
                                switch selectedTab {
                                case .info:
                                    infoTabView
                                case .variations:
                                    variationsTabView
                                case .links:
                                    linksTabView
                                case .clips:
                                    clipsTabView
                                }
                            }
                            .padding(.horizontal, 16)
                            .padding(.top, 8)
                            .animation(.easeInOut(duration: 0.15), value: selectedTab)
                            .transition(.opacity)
                            .background(Color.clear) // Ensures the full area is tappable
                            .contentShape(Rectangle()) // Makes the entire area receptive to gestures
                            // SwiftUI drag gesture for basic detection
                            .trackpadSwipe(
                                onSwipeLeft: {
                                    if let currentIndex = Tab.allCases.firstIndex(of: selectedTab),
                                       currentIndex < Tab.allCases.count - 1 {
                                        withAnimation(.easeInOut(duration: 0.25)) {
                                            selectedTab = Tab.allCases[currentIndex + 1]
                                        }
                                    }
                                },
                                onSwipeRight: {
                                    if let currentIndex = Tab.allCases.firstIndex(of: selectedTab),
                                       currentIndex > 0 {
                                        withAnimation(.easeInOut(duration: 0.25)) {
                                            selectedTab = Tab.allCases[currentIndex - 1]
                                        }
                                    }
                                }
                            )
                            // Native NSSwipeGestureRecognizer for direct gesture recognition
                            .onSwipeGesture(
                                onSwipeLeft: {
                                    if let currentIndex = Tab.allCases.firstIndex(of: selectedTab), 
                                       currentIndex < Tab.allCases.count - 1 {
                                        withAnimation(.easeInOut(duration: 0.25)) {
                                            selectedTab = Tab.allCases[currentIndex + 1]
                                        }
                                    }
                                },
                                onSwipeRight: {
                                    if let currentIndex = Tab.allCases.firstIndex(of: selectedTab),
                                       currentIndex > 0 {
                                        withAnimation(.easeInOut(duration: 0.25)) {
                                            selectedTab = Tab.allCases[currentIndex - 1]
                                        }
                                    }
                                }
                            )
                            // Trackpad horizontal scrolling detection
                            .onTrackpadScroll(
                                onScrollLeft: {
                                    if let currentIndex = Tab.allCases.firstIndex(of: selectedTab),
                                       currentIndex > 0 {
                                        withAnimation(.easeInOut(duration: 0.25)) {
                                            selectedTab = Tab.allCases[currentIndex - 1]
                                        }
                                    }
                                },
                                onScrollRight: {
                                    if let currentIndex = Tab.allCases.firstIndex(of: selectedTab),
                                       currentIndex < Tab.allCases.count - 1 {
                                        withAnimation(.easeInOut(duration: 0.25)) {
                                            selectedTab = Tab.allCases[currentIndex + 1]
                                        }
                                    }
                                }
                            )
                        }
                        .padding(.bottom, 40)
                    }
                    .coordinateSpace(name: "scrollView")
                    .onPreferenceChange(ScrollOffsetPreferenceKey.self) { value in
                        scrollOffset = value
                    }
                }
            }
        }
        .background(theme.background)
        .onAppear {
            loadRecentItems()
        }
        .onChange(of: isEditing) { _, newValue in
            if !newValue { // When exiting edit mode
                saveChanges()
            }
        }
        // Add keyboard shortcuts for tab navigation
        .onKeyPress(.leftArrow) {
            if let currentIndex = Tab.allCases.firstIndex(of: selectedTab), currentIndex > 0 {
                withAnimation(.easeInOut(duration: 0.25)) {
                    selectedTab = Tab.allCases[currentIndex - 1]
                }
                return .handled
            }
            return .ignored
        }
        .onKeyPress(.rightArrow) {
            if let currentIndex = Tab.allCases.firstIndex(of: selectedTab), 
               currentIndex < Tab.allCases.count - 1 {
                withAnimation(.easeInOut(duration: 0.25)) {
                    selectedTab = Tab.allCases[currentIndex + 1]
                }
                return .handled
            }
            return .ignored
        }
    }
    
    // Info Tab Content
    private var infoTabView: some View {
                            VStack(alignment: .leading, spacing: 20) {
                                // Series
                                HStack(alignment: .center, spacing: 16) {
                                    Image(systemName: "list.bullet")
                                        .frame(width: 24)
                                        .foregroundStyle(theme.secondary)
                                    
                                    Text("Series")
                                        .font(DesignSystem.Typography.medium(size: 12))
                                        .foregroundStyle(theme.primary)
                                        .tracking(0.5)
                                        .frame(width: 100, alignment: .leading)
                                    
                                    Spacer()
                                    
                                    if isEditing {
                                        TextField("Series Name", text: $seriesName)
                                            .font(DesignSystem.Typography.regular(size: 12))
                                            .textFieldStyle(.plain)
                                            .padding(6)
                                            .background(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97))
                                            .cornerRadius(6)
                                            .frame(maxWidth: .infinity)
                                    } else {
                                        if let series = document.series {
                                            Text(series.name)
                                                .font(DesignSystem.Typography.medium(size: 12))
                                                .foregroundStyle(theme.primary)
                                        } else {
                                            Text("None")
                                                .font(DesignSystem.Typography.regular(size: 12))
                                                .foregroundStyle(theme.primary)
                                        }
                                    }
                                }
                                
                                // Date Presented
                                HStack(alignment: .center, spacing: 16) {
                                    Image(systemName: "calendar")
                                        .frame(width: 24)
                                        .foregroundStyle(theme.secondary)
                                    
                                    Text("Date Presented")
                                        .font(DesignSystem.Typography.medium(size: 12))
                                        .foregroundStyle(theme.primary)
                                        .tracking(0.5)
                                        .frame(width: 100, alignment: .leading)
                                    
                                    Spacer()
                                    
                                    if isEditing {
                                        TextField("Date (e.g. Jan 1, 2023)", text: $datePresented)
                                            .font(DesignSystem.Typography.regular(size: 12))
                                            .textFieldStyle(.plain)
                                            .padding(6)
                                            .background(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97))
                                            .cornerRadius(6)
                                            .frame(maxWidth: .infinity)
                                    } else {
                                        if let date = document.variations.first?.datePresented {
                                            Text(formatDate(date))
                                                .font(DesignSystem.Typography.regular(size: 12))
                                                .foregroundStyle(theme.primary)
                                        } else {
                                            Text("None")
                                                .font(DesignSystem.Typography.regular(size: 12))
                                                .foregroundStyle(theme.primary)
                                        }
                                    }
                                }
                                
                                // Location
                                HStack(alignment: .center, spacing: 16) {
                                    Image(systemName: "mappin.and.ellipse")
                                        .frame(width: 24)
                                        .foregroundStyle(theme.secondary)
                                    
                                    Text("Location")
                                        .font(DesignSystem.Typography.medium(size: 12))
                                        .foregroundStyle(theme.primary)
                                        .tracking(0.5)
                                        .frame(width: 100, alignment: .leading)
                                    
                                    Spacer()
                                    
                                    if isEditing {
                                        TextField("Location", text: $location)
                                            .font(DesignSystem.Typography.regular(size: 12))
                                            .textFieldStyle(.plain)
                                            .padding(6)
                                            .background(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97))
                                            .cornerRadius(6)
                                            .frame(maxWidth: .infinity)
                                    } else {
                                        if let location = document.variations.first?.location, !location.isEmpty {
                                            Text(location)
                                                .font(DesignSystem.Typography.regular(size: 12))
                                                .foregroundStyle(theme.primary)
                                        } else {
                                            Text("None")
                                                .font(DesignSystem.Typography.regular(size: 12))
                                                .foregroundStyle(theme.primary)
                                        }
                                    }
                                }
                                
                                // Tags
                                
                                // Tags
                                HStack(alignment: .center, spacing: 16) {
                                    Image(systemName: "tag")
                                        .frame(width: 24)
                                        .foregroundStyle(theme.secondary)
                                    
                                    Text("Tags")
                                        .font(DesignSystem.Typography.medium(size: 12))
                                        .foregroundStyle(theme.primary)
                                        .tracking(0.5)
                                        .frame(width: 100, alignment: .leading)
                                    
                                    Spacer()
                                    
                                    if isEditing {
                                        VStack(alignment: .leading, spacing: 8) {
                                            // Tag entry field
                                            HStack {
                                                TextField("Add new tag", text: $newTag, onCommit: {
                                                    if !newTag.isEmpty {
                                                        tags.insert(newTag)
                                                        newTag = ""
                                                    }
                                                })
                                                .font(DesignSystem.Typography.regular(size: 12))
                                                .textFieldStyle(.plain)
                                                .padding(6)
                                                .background(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97))
                                                .cornerRadius(6)
                                                
                                                Button(action: {
                                                    if !newTag.isEmpty {
                                                        tags.insert(newTag)
                                                        newTag = ""
                                                    }
                                                }) {
                                                    Image(systemName: "plus.circle.fill")
                                                        .font(.system(size: 16))
                                                        .foregroundStyle(theme.accent)
                                                }
                                                .buttonStyle(.plain)
                                                .disabled(newTag.isEmpty)
                                            }
                                            
                                            // Existing tags with remove buttons
                                            if !tags.isEmpty {
                                                FlowLayout(spacing: 6) {
                                                    ForEach(Array(tags), id: \.self) { tag in
                                                        HStack(spacing: 4) {
                                                            Text(tag)
                                                                .font(DesignSystem.Typography.medium(size: 12))
                                                                .tracking(0.5)
                                                                .foregroundStyle(tagColor(for: tag))
                                                                .padding(.horizontal, 6)
                                                                .padding(.vertical, 2)
                                                            
                                                            Button(action: {
                                                                tags.remove(tag)
                                                            }) {
                                                                Image(systemName: "xmark.circle.fill")
                                                                    .font(.system(size: 12))
                                                                    .foregroundStyle(theme.secondary)
                                                            }
                                                            .buttonStyle(.plain)
                                                        }
                                                        .overlay(
                                                            RoundedRectangle(cornerRadius: 6)
                                                                .stroke(tagColor(for: tag), lineWidth: 1)
                                                        )
                                                    }
                                                }
                                            }
                                        }
                                        .frame(maxWidth: .infinity)
                                    } else {
                                        if tags.isEmpty {
                                            Text("None")
                                                .font(DesignSystem.Typography.regular(size: 12))
                                                .foregroundStyle(theme.primary)
                                        } else {
                        // For non-empty tags, we'll show a compact representation
                        HStack(spacing: 4) {
                            ForEach(Array(tags).prefix(3), id: \.self) { tag in
                                                    Text(tag)
                                    .font(DesignSystem.Typography.medium(size: 12))
                                    .tracking(0.5)
                                    .foregroundStyle(tagColor(for: tag))
                                    .padding(.horizontal, 10)
                                                        .padding(.vertical, 3)
                                    .overlay(
                                                            RoundedRectangle(cornerRadius: 6)
                                            .stroke(tagColor(for: tag), lineWidth: 1)
                                    )
                            }
                            
                            if tags.count > 3 {
                                Text("+\(tags.count - 3)")
                                    .font(DesignSystem.Typography.regular(size: 10))
                                            .foregroundStyle(theme.secondary)
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Variations Tab Content
    private var variationsTabView: some View {
        VStack(alignment: .leading, spacing: 16) {
                                    let variations = loadVariations()
                                    
                                    if variations.isEmpty && (!document.isVariation || document.parentVariationId == nil) {
                Text("No variations")
                                            .font(DesignSystem.Typography.regular(size: 12))
                    .foregroundStyle(theme.secondary)
                    .padding(.leading, 4)
                                    } else {
                                            // Show Original document button only when viewing a variation
                                            if document.isVariation && document.parentVariationId != nil {
                                                // Load the original document
                                                if let originalDoc = loadDocumentById(document.parentVariationId!) {
                        HoverableRowButton(
                            icon: "doc.text", 
                            label: "Original", 
                            content: originalDoc.title.isEmpty ? "Untitled" : originalDoc.title,
                            action: {
                                                        // Navigate to the original document
                                                        NotificationCenter.default.post(
                                                            name: NSNotification.Name("OpenDocument"),
                                                            object: nil,
                                                            userInfo: ["documentId": originalDoc.id]
                                                        )
                            }
                        )
                    }
                }
                
                // Variation buttons
                                            ForEach(variations) { variation in
                    HoverableRowButton(
                        icon: "doc.append", 
                        label: "Variation", 
                        content: variation.title.isEmpty ? "Untitled" : variation.title,
                        action: {
                                                    // Open the variation
                                                    NotificationCenter.default.post(
                                                        name: NSNotification.Name("OpenDocument"),
                                                        object: nil,
                                                        userInfo: ["documentId": variation.id]
                                                    )
                        }
                    )
                }
            }
        }
    }
    
    // Hoverable Row Button component for consistent styling
    private struct HoverableRowButton: View {
        let icon: String
        let label: String
        let content: String
        let action: () -> Void
        @Environment(\.themeColors) var theme
        @Environment(\.colorScheme) var colorScheme
        @State private var isHovering = false
        
        var body: some View {
            Button(action: action) {
                HStack(alignment: .center, spacing: 16) {
                    Image(systemName: icon)
                        .frame(width: 24)
                        .foregroundStyle(theme.secondary)
                    
                    Text(label)
                        .font(DesignSystem.Typography.medium(size: 12))
                        .foregroundStyle(theme.primary)
                        .tracking(0.5)
                        .frame(width: 100, alignment: .leading)
                    
                    Spacer()
                    
                    Text(content)
                        .font(DesignSystem.Typography.regular(size: 12))
                        .foregroundStyle(theme.primary)
                }
                .padding(.vertical, 6)
                .padding(.horizontal, 8)
                .background(
                    RoundedRectangle(cornerRadius: 6)
                        .fill(isHovering ? 
                              theme.accent.opacity(0.15) : 
                              Color.clear)
                )
                .contentShape(Rectangle())
            }
            .buttonStyle(.plain)
            .onHover { hovering in
                isHovering = hovering
                if hovering {
                    NSCursor.pointingHand.push()
                } else {
                    if NSCursor.current == NSCursor.pointingHand {
                        NSCursor.pop()
                    }
                }
            }
        }
    }
    
    // Links Tab Content
    private var linksTabView: some View {
        VStack(alignment: .leading, spacing: 16) {
            if document.links.isEmpty {
                Text("No links")
                    .font(DesignSystem.Typography.regular(size: 12))
                    .foregroundStyle(theme.secondary)
                    .padding(.leading, 4)
            } else {
                // Links list
                ForEach(document.links) { link in
                    HoverableRowButton(
                        icon: "link", 
                        label: link.title.isEmpty ? "Link" : link.title, 
                        content: link.url,
                        action: {
                            // Open the link
                            if let url = URL(string: link.url) {
                                NSWorkspace.shared.open(url)
                            }
                        }
                    )
                }
            }
        }
    }
    
    // Clips Tab Content
    private var clipsTabView: some View {
        VStack(alignment: .leading, spacing: 16) {
            // This is a new feature, so we'll start with an empty state
            Text("No clips")
                .font(DesignSystem.Typography.regular(size: 12))
                .foregroundStyle(theme.secondary)
                .padding(.leading, 4)
        }
    }
    
    private func saveChanges() {
        var updatedDoc = document
        updatedDoc.title = title
        updatedDoc.subtitle = subtitle
        
        // Update series if needed
        if !seriesName.isEmpty {
            if updatedDoc.series == nil || updatedDoc.series?.name != seriesName {
            updatedDoc.series = DocumentSeries(
                id: UUID(),
                name: seriesName,
                documents: [document.id],
                order: 0
            )
            }
        } else {
            updatedDoc.series = nil
        }
        
        // Update variation data
        if var firstVariation = updatedDoc.variations.first {
            // Update location
            firstVariation.location = location
            
            
            // Update date if provided
            if !datePresented.isEmpty {
                let formatter = DateFormatter()
                formatter.dateFormat = "MMM d, yyyy"
                if let date = formatter.date(from: datePresented) {
                    firstVariation.datePresented = date
            }
            }
            
            // Save variation back to document
            updatedDoc.variations[0] = firstVariation
        } else {
            // Create a new variation
            let variation = DocumentVariation(
                id: UUID(),
                name: "Original",
                documentId: document.id,
                parentDocumentId: document.id,
                createdAt: Date(),
                datePresented: {
                    if !datePresented.isEmpty {
                        let formatter = DateFormatter()
                        formatter.dateFormat = "MMM d, yyyy"
                        return formatter.date(from: datePresented)
                    }
                    return nil
                }(),
                location: location.isEmpty ? nil : location
            )
            
            updatedDoc.variations = [variation]
        }
        
        // Update tags
        updatedDoc.tags = Array(tags)
        
        // Save to disk
        updatedDoc.save()
        
        // Update binding
        document = updatedDoc
        
        // Notify of change
        NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
    }
    
    private func removeTag(_ tag: String) {
        tags.remove(tag)
        NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
    }
    
    private func tagColor(for tag: String) -> Color {
        return colorManager.color(for: tag)
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy"
        return formatter.string(from: date)
    }
    
    private func loadVariations() -> [Letterspace_CanvasDocument] {
        print("🔍 Loading variations for document ID: \(document.id)")
        guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            print("❌ Could not access documents directory")
            return []
        }
        let appDirectory = documentsPath.appendingPathComponent("Letterspace Canvas")
        
        do {
            let fileURLs = try FileManager.default.contentsOfDirectory(at: appDirectory, includingPropertiesForKeys: nil)
                .filter { $0.pathExtension == "canvas" }
            
            let variations = fileURLs.compactMap { url -> Letterspace_CanvasDocument? in
                do {
                    let data = try Data(contentsOf: url)
                    let doc = try JSONDecoder().decode(Letterspace_CanvasDocument.self, from: data)
                    
                    // Only return documents that are variations of the current document
                    if doc.isVariation, doc.parentVariationId == document.id {
                        return doc
                    }
                    return nil
                } catch {
                    print("❌ Error loading document at \(url): \(error)")
                    return nil
                }
            }
            
            print("📊 Found \(variations.count) variations for document ID: \(document.id)")
            return variations
        } catch {
            print("❌ Error accessing documents directory: \(error)")
            return []
        }
    }
    
    // Helper function to load a document by ID
    private func loadDocumentById(_ documentId: String) -> Letterspace_CanvasDocument? {
        print("🔍 Loading document with ID: \(documentId)")
        guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            print("❌ Could not access documents directory")
            return nil
        }
        let appDirectory = documentsPath.appendingPathComponent("Letterspace Canvas")
        
        do {
            let fileURLs = try FileManager.default.contentsOfDirectory(at: appDirectory, includingPropertiesForKeys: nil)
                .filter { $0.pathExtension == "canvas" }
            
            for url in fileURLs {
                do {
                    let data = try Data(contentsOf: url)
                    let doc = try JSONDecoder().decode(Letterspace_CanvasDocument.self, from: data)
                    
                    if doc.id == documentId {
                        print("✅ Found document: \(doc.title) (ID: \(doc.id))")
                        return doc
                    }
                } catch {
                    print("❌ Error loading document at \(url): \(error)")
                }
            }
            
            print("❌ Document with ID \(documentId) not found")
            return nil
        } catch {
            print("❌ Error accessing documents directory: \(error)")
            return nil
        }
    }

    private func addHeaderImage() {
        let panel = NSOpenPanel()
        panel.allowsMultipleSelection = false
        panel.canChooseDirectories = false
        panel.canChooseFiles = true
        panel.allowedContentTypes = [.image]
        
        if panel.runModal() == .OK, let url = panel.url {
            guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
                return
            }
            
            do {
                // Create document image directory if needed
                let documentPath = documentsPath.appendingPathComponent(document.id)
                let imagesPath = documentPath.appendingPathComponent("Images")
                
                if !FileManager.default.fileExists(atPath: imagesPath.path) {
                    try FileManager.default.createDirectory(at: imagesPath, withIntermediateDirectories: true)
                }
                
                // Generate a unique filename
                let fileName = "header_\(UUID().uuidString).\(url.pathExtension)"
                let fileURL = imagesPath.appendingPathComponent(fileName)
                
                // Copy the image to the document's image directory
                try FileManager.default.copyItem(at: url, to: fileURL)
                
                // Create a new header element or update existing
                var updatedDoc = document
                if let index = updatedDoc.elements.firstIndex(where: { $0.type == .headerImage }) {
                    updatedDoc.elements[index].content = fileName
                } else {
                    let headerElement = DocumentElement(type: .headerImage, content: fileName)
                    updatedDoc.elements.insert(headerElement, at: 0)
                }
                
                // Save document and update binding
                document = updatedDoc
                updatedDoc.save()
            } catch {
                print("Error adding header image: \(error)")
            }
        }
    }

    // Function to generate AI summary
    private func generateAISummary() {
        // Set generating state to true to show loading indicator
        isGeneratingSummary = true
        
        // Get the document content from the elements
        let documentContent = localDocument.elements
            .filter { $0.type == .textBlock }
            .map { $0.content }
            .joined(separator: "\n\n")
        
        // Create a CanvasDocument with the content
        let canvasDoc = CanvasDocument()
        canvasDoc.content = NSAttributedString(string: documentContent)
        canvasDoc.metadata.title = localDocument.title
        
        // Generate the summary
        canvasDoc.generateSummary { summary in
            // Update on the main thread to ensure UI updates properly
            DispatchQueue.main.async {
                // Update the summary text state variable
                self.summaryText = summary
                self.isGeneratingSummary = false
                
                // Update the local document copy
                self.localDocument.summary = summary
                
                // Save the document without updating the binding
                var updatedDoc = self.document
                updatedDoc.summary = summary
                updatedDoc.save()
            }
        }
    }
    
    // Function to remove the summary
    private func removeSummary() {
        // Update on the main thread to ensure UI updates properly
        DispatchQueue.main.async {
            // Clear the summary text
            self.summaryText = ""
            
            // Update the local document copy
            self.localDocument.summary = nil
            
            // Save the document without updating the binding
            var updatedDoc = self.document
            updatedDoc.summary = nil
            updatedDoc.save()
        }
    }
}

// Add this helper view for the button background
struct AddHeaderButtonBackground: View {
    let colorScheme: ColorScheme
    
    var body: some View {
        let strokeColor = colorScheme == .dark 
            ? Color.white.opacity(0.15) 
            : Color.black.opacity(0.1)
        
        let backgroundColor = colorScheme == .dark 
            ? Color.black.opacity(0.2)
            : Color.black.opacity(0.03)
        
        RoundedRectangle(cornerRadius: 8)
            .stroke(
                strokeColor,
                style: StrokeStyle(lineWidth: 1, dash: [4])
            )
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(backgroundColor)
            )
    }
}

struct DocumentListItemOptimized: View {
    @Environment(\.colorScheme) private var colorScheme
    @Environment(\.themeColors) private var theme
    @StateObject private var colorManager = TagColorManager.shared
    
    let document: Letterspace_CanvasDocument
    @Binding var documents: [Letterspace_CanvasDocument]
    let isSelected: Bool
    let isSelectionMode: Bool
    let onLongPress: () -> Void
    let pinnedDocuments: Set<String>
    let wipDocuments: Set<String>
    let calendarDocuments: Set<String>
    let onPin: (String) -> Void
    let onWIP: (String) -> Void
    let onCalendar: (String) -> Void
    let visibleColumns: Set<String>
    let dateFilterType: DateFilterType
    let onOpen: (Letterspace_CanvasDocument) -> Void
    let onShowDetails: (Letterspace_CanvasDocument) -> Void
    
    @State private var isHovering = false
    @State private var showDetailsCard = false
    @State private var showScheduleSheet = false
    @State private var documentToSchedule: Letterspace_CanvasDocument?
    @State private var calendarContextAnchor: CGPoint = .zero
    @State private var showCalendarContext: Bool = false
    
    var body: some View {
        HStack(spacing: 0) {
            // Status indicators
            HStack(spacing: 4) {
                if !isSelectionMode {
                    // Status indicators that appear on hover
                    if isHovering {
                        HStack(spacing: 2) {
                            Button(action: {
                                onPin(document.id)
                            }) {
                                Image(systemName: "pin.fill")
                                    .font(.system(size: 12))
                                    .foregroundStyle(pinnedDocuments.contains(document.id) ? .green : theme.secondary.opacity(0.4))
                            }
                            .buttonStyle(.plain)
                            .help("Pin to Top")
                            
                            Button(action: {
                                onWIP(document.id)
                            }) {
                                Image(systemName: "clock.fill")
                                    .font(.system(size: 12))
                                    .foregroundStyle(wipDocuments.contains(document.id) ? .orange : theme.secondary.opacity(0.4))
                            }
                            .buttonStyle(.plain)
                            .help("Mark as Work in Progress")
                            
                            Button(action: {
                                showCalendarContext = true
                            }) {
                                Image(systemName: "calendar")
                                    .font(.system(size: 12))
                                    .foregroundStyle(calendarDocuments.contains(document.id) ? .blue : theme.secondary.opacity(0.4))
                            }
                            .buttonStyle(.plain)
                            .help("Add to Calendar")
                            .popover(isPresented: $showCalendarContext, arrowEdge: .trailing) {
                                CalendarContextMenu(
                                    document: document,
                                    showScheduleSheet: $showCalendarContext,
                                    onCalendar: onCalendar
                                )
                            }
                        }
                        .padding(.horizontal, 2)
                    
                        // Non-hover indicators
                        if pinnedDocuments.contains(document.id) {
                            Circle()
                                .fill(Color.green)
                                .frame(width: 8, height: 8)
                        }
                        if wipDocuments.contains(document.id) {
                            Circle()
                                .fill(Color.orange)
                                .frame(width: 8, height: 8)
                        }
                        if calendarDocuments.contains(document.id) {
                            Circle()
                                .fill(Color.blue)
                                .frame(width: 8, height: 8)
                        }
                    } else {
                        // Non-hover indicators
                        if pinnedDocuments.contains(document.id) {
                            Circle()
                                .fill(Color.green)
                                .frame(width: 8, height: 8)
                        }
                        if wipDocuments.contains(document.id) {
                            Circle()
                                .fill(Color.orange)
                                .frame(width: 8, height: 8)
                        }
                        if calendarDocuments.contains(document.id) {
                            Circle()
                                .fill(Color.blue)
                                .frame(width: 8, height: 8)
                        }
                    }
                }
            }
            .frame(width: 24)
            .padding(.leading, 12)
            .padding(.trailing, 16)

            // Selection checkbox
            if isSelectionMode {
                Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                    .font(.system(size: 16))
                    .foregroundStyle(isSelected ? theme.accent : theme.secondary)
                    .frame(width: 24)
            }
            
            // Document Icon and Title
            HStack(spacing: 8) {
                Image(systemName: "doc.text")
                    .font(.system(size: 12))
                    .foregroundStyle(theme.secondary)
                    .frame(width: 24, height: 24)
                    .background(theme.secondary.opacity(0.1))
                    .clipShape(Circle())
                
                Text(document.title.isEmpty ? "Untitled" : document.title)
                    .font(.system(size: 12, weight: .semibold))
                    .foregroundStyle(Color.black)
                    .lineLimit(1)
                    .truncationMode(.tail)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding(.trailing, 16)
            
            // Tags
            if visibleColumns.contains("tags") {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 4) {
                        if let tags = document.tags {
                            ForEach(tags, id: \.self) { tag in
                                Text(tag)
                                    .font(.custom("InterTight-Regular", size: 11))
                                    .foregroundStyle(theme.primary)
                                    .padding(.horizontal, 6)
                                    .padding(.vertical, 2)
                                    .background(tagColor(for: tag).opacity(0.2))
                                    .cornerRadius(4)
                            }
                        }
                    }
                }
                .frame(maxWidth: 200)
            }
            
            Spacer()
            
            // Details button
            HStack {
                if isHovering && !isSelectionMode {
                    Button(action: {
                        withAnimation(.easeInOut(duration: 0.2)) {
                        showDetailsCard = true
                        }
                    }) {
                        Image(systemName: "info.circle")
                            .font(.custom("InterTight-Regular", size: 11))
                            .foregroundStyle(theme.secondary.opacity(0.7))
                    }
                    .buttonStyle(.plain)
                    .help("View Details")
                }
            }
            .frame(width: 60)  // Reserve consistent space for the button
            .padding(.horizontal, 8)
        }
        .frame(height: 36)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(isSelected ? theme.accent.opacity(0.2) : 
                     (colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97)))
                .opacity(isSelected ? 1 : (isHovering ? 1 : 0))
        )
        .contentShape(Rectangle())
        .onTapGesture {
            onOpen(document)
        }
        .onLongPressGesture(minimumDuration: 0.5) {
            onLongPress()
        }
        .onHover { hovering in
            isHovering = hovering
        }
        .sheet(isPresented: $showDetailsCard) {
            DocumentDetailsCard(document: .constant(document))
                .frame(width: 400)
                .interactiveDismissDisabled(true)
        }
        .sheet(isPresented: $showScheduleSheet) {
            if let doc = documentToSchedule {
                ScheduleSheet(document: doc, isPresented: $showScheduleSheet)
            }
        }
        .help("View Details")
    }
    
    private func tagColor(for tag: String) -> Color {
        return colorManager.color(for: tag)
    }
    
    private func formatDate(_ date: Date) -> String {
        let calendar = Calendar.current
        let timeFormatter = DateFormatter()
        timeFormatter.dateFormat = "h:mm a"
        
        if calendar.isDateInToday(date) {
            return "Today, \(timeFormatter.string(from: date))"
        }
        
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .none
        return formatter.string(from: date)
    }
}

struct DocumentThumbnail: View {
    let title: String
    let date: String
    @Environment(\.themeColors) var theme
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Preview area
            Rectangle()
                .fill(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.9))
                .frame(width: 180, height: 120)
                .clipShape(RoundedRectangle(cornerRadius: 8))
            
            // Document info
            VStack(alignment: .leading, spacing: 4) {
                Text(title)
                    .font(.system(size: 14, weight: .medium))
                    .foregroundStyle(theme.primary)
                Text(date)
                    .font(.system(size: 12))
                    .foregroundStyle(theme.secondary)
            }
        }
        .frame(width: 180)
        .padding(12)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(colorScheme == .dark ? Color(.sRGB, white: 0.2) : .white)
                .shadow(color: .black.opacity(0.1), radius: 4, x: 0, y: 2)
        )
    }
}

struct ScrollOffsetPreferenceKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

struct ScrollViewConfigurator: NSViewRepresentable {
    let shouldFlash: Bool
    
    func makeNSView(context: Context) -> NSView {
        let view = NSView()
        return view
    }
    
    func updateNSView(_ nsView: NSView, context: Context) {
        DispatchQueue.main.async {
            if let scrollView = nsView.enclosingScrollView {
                scrollView.scrollerStyle = .overlay
                scrollView.scrollerKnobStyle = .light
                scrollView.verticalScroller?.alphaValue = 0.4  // Make it more transparent
                
                
                if let scroller = scrollView.verticalScroller {
                    scroller.controlSize = .mini
                    
                    // Make the scroller even thinner
                    let knobWidth: CGFloat = 2  // Original is usually 3-4px
                    scroller.knobProportion = knobWidth / scroller.bounds.width
                }
                
                if shouldFlash {
                    scrollView.flashScrollers()
                }
            }
        }
    }
}

struct CustomScrollModifier: ViewModifier {
    let shouldFlash: Bool
    
    func body(content: Content) -> some View {
        content
            .background(ScrollViewConfigurator(shouldFlash: shouldFlash))
    }
}

extension View {
    func customScroll(shouldFlash: Bool = false) -> some View {
        modifier(CustomScrollModifier(shouldFlash: shouldFlash))
    }
}

struct TagColorPreference: Codable {
    let tag: String
    let colorHex: String
}

class TagColorManager: ObservableObject {
    static let shared = TagColorManager()
    @Published var colorPreferences: [String: Color] = [:]
    
    private let defaultColors: [Color] = [
        Color(hex: "#dc2626"),  // Crimson
        Color(hex: "#f97316"),  // Tangerine
        Color(hex: "#f59e0b"),  // Amber
        Color(hex: "#10b981"),  // Emerald
        Color(hex: "#0d9488"),  // Teal
        Color(hex: "#2563eb"),  // Cobalt
        Color(hex: "#4f46e5"),  // Indigo
        Color(hex: "#9333ea"),  // Purple
        Color(hex: "#db2777"),  // Magenta
        Color(hex: "#475569"),  // Slate
        Color(hex: "#b45309"),  // Sienna
        Color(hex: "#059669")   // Jade
    ]
    
    init() {
        loadColorPreferences()
    }
    
    func color(for tag: String) -> Color {
        if let savedColor = colorPreferences[tag] {
            return savedColor
        }
        
        // Generate a deterministic color based on the tag's hash
        let hash = tag.utf8.reduce(0) { ($0 << 5) &+ Int($1) }
        let color = defaultColors[abs(hash) % defaultColors.count]
        
        // Save this color preference immediately
        colorPreferences[tag] = color
        saveColorPreferences()
        
        return color
    }
    
    func setColor(_ color: Color, for tag: String) {
        colorPreferences[tag] = color
        saveColorPreferences()
        
        // Notify that documents should update to reflect new color
        NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
    }
    
    private func loadColorPreferences() {
        if let data = UserDefaults.standard.data(forKey: "TagColorPreferences"),
           let preferences = try? JSONDecoder().decode([TagColorPreference].self, from: data) {
            colorPreferences = Dictionary(uniqueKeysWithValues: preferences.map { (
                $0.tag,
                Color(hex: $0.colorHex)
            )})
        }
    }
    
    private func saveColorPreferences() {
        let preferences = colorPreferences.map { (tag, color) -> TagColorPreference in
            return TagColorPreference(tag: tag, colorHex: color.toHex())
        }
        
        if let data = try? JSONEncoder().encode(preferences) {
            UserDefaults.standard.set(data, forKey: "TagColorPreferences")
        }
    }
}

struct TagManager: View {
    @Environment(\.dismiss) var dismiss
    @Environment(\.colorScheme) var colorScheme
    @Environment(\.themeColors) var theme
    let allTags: [String]
    @State private var editingTag: String?
    @State private var newName: String = ""
    @State private var tagToDelete: String?
    @State private var showDeleteAlert: Bool = false
    @StateObject private var colorManager = TagColorManager.shared
    @State private var selectedTag: String?
    @State private var hoveredTag: String?
    @State private var hoveredColor: String?
    @State private var showColorPicker: Bool = false
    @State private var hoveredPencil: String? = nil
    @State private var hoveredTrash: String? = nil
    
    private let colorPalette: [(name: String, color: Color)] = [
        ("Crimson", Color(hex: "#dc2626")),      // Bright red
        ("Tangerine", Color(hex: "#f97316")),    // Bright orange
        ("Amber", Color(hex: "#f59e0b")),        // Golden yellow
        ("Emerald", Color(hex: "#10b981")),      // Rich green
        ("Teal", Color(hex: "#0d9488")),         // Deep teal
        ("Cobalt", Color(hex: "#2563eb")),       // Vibrant blue
        ("Indigo", Color(hex: "#4f46e5")),       // Deep indigo
        ("Purple", Color(hex: "#9333ea")),       // Rich purple
        ("Magenta", Color(hex: "#db2777")),      // Bright pink
        ("Slate", Color(hex: "#475569")),        // Dark gray-blue
        ("Sienna", Color(hex: "#b45309")),       // Brown
        ("Jade", Color(hex: "#059669"))          // Jade green
    ]
    
    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Text("Tag Manager")
                    .font(.system(size: 13, weight: .semibold))
                    .foregroundStyle(theme.primary)
                Spacer()
                
                Button(action: { dismiss() }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.system(size: 20))
                        .foregroundStyle(theme.secondary)
                }
                .buttonStyle(.plain)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            
            Divider()
                .padding(.bottom, 8)
            
            // Tag list
            ScrollView {
                VStack(spacing: 4) {
                    ForEach(allTags, id: \.self) { tag in
                        VStack(alignment: .leading, spacing: 0) {
                            HStack(spacing: 8) {
                                if editingTag == tag {
                                    HStack {
                                        TextField("Tag name", text: $newName)
                                            .font(.system(size: 13))
                                            .textFieldStyle(.plain)
                                            .padding(6)
                                            .background(theme.background)
                                            .cornerRadius(6)
                                            .onSubmit {
                                                renameTag(from: tag, to: newName)
                                                editingTag = nil
                                            }
                                        
                                        // Clear and Submit buttons
                                        HStack(spacing: 8) {
                                            Button(action: {
                                                editingTag = nil
                                                newName = tag
                                            }) {
                                                Image(systemName: "xmark.circle.fill")
                                                    .font(.system(size: 14))
                                                    .foregroundStyle(theme.secondary)
                                            }
                                            .buttonStyle(.plain)
                                            
                                            Button(action: {
                                                renameTag(from: tag, to: newName)
                                                editingTag = nil
                                            }) {
                                                Image(systemName: "checkmark.circle.fill")
                                                    .font(.system(size: 14))
                                                    .foregroundStyle(theme.accent)
                                            }
                                            .buttonStyle(.plain)
                                            .disabled(newName.isEmpty || newName == tag)
                                        }
                                    }
                                } else {
                                    HStack(spacing: 8) {
                                        Circle()
                                            .stroke(colorManager.color(for: tag), lineWidth: 2)
                                            .background(
                                                Circle()
                                                    .fill(Color(colorScheme == .dark ? .black : .white).opacity(0.1))
                                            )
                                            .frame(width: hoveredTag == tag ? 10 : 8, height: hoveredTag == tag ? 10 : 8)
                                            .animation(.spring(response: 0.2), value: hoveredTag)
                                            .background(
                                                Circle()
                                                    .fill(colorScheme == .dark ? 
                                                        Color.white.opacity(hoveredTag == tag ? 0.1 : 0) :
                                                        Color.black.opacity(hoveredTag == tag ? 0.05 : 0))
                                                    .frame(width: 20, height: 20)
                                            )
                                            .onTapGesture {
                                                selectedTag = tag
                                                showColorPicker = true
                                            }
                                        
                                        Text(tag)
                                            .font(.system(size: 13))
                                            .foregroundStyle(theme.primary)
                                    }
                                }
                                
                                Spacer()
                                
                                if hoveredTag == tag && editingTag != tag {
                                    // Action buttons
                                    HStack(spacing: 4) {
                                        Button(action: {
                                            editingTag = tag
                                            newName = tag
                                        }) {
                                            Image(systemName: "pencil")
                                                .font(.system(size: 12))
                                                .foregroundStyle(theme.secondary)
                                                .padding(4)
                                                .background(
                                                    Circle()
                                                        .fill(colorScheme == .dark ? 
                                                            Color.white.opacity(hoveredPencil == tag ? 0.1 : 0) :
                                                            Color.black.opacity(hoveredPencil == tag ? 0.05 : 0))
                                                )
                                        }
                                        .buttonStyle(.plain)
                                        .onHover { isHovered in
                                            withAnimation(.easeOut(duration: 0.15)) {
                                                hoveredPencil = isHovered ? tag : nil
                                            }
                                        }
                                        
                                        Button(action: {
                                            tagToDelete = tag
                                            showDeleteAlert = true
                                        }) {
                                            Image(systemName: "trash")
                                                .font(.system(size: 12))
                                                .foregroundStyle(Color(hex: "#ef4444"))
                                                .padding(4)
                                                .background(
                                                    Circle()
                                                        .fill(colorScheme == .dark ? 
                                                            Color.white.opacity(hoveredTrash == tag ? 0.1 : 0) :
                                                            Color.black.opacity(hoveredTrash == tag ? 0.05 : 0))
                                                )
                                        }
                                        .buttonStyle(.plain)
                                        .onHover { isHovered in
                                            withAnimation(.easeOut(duration: 0.15)) {
                                                hoveredTrash = isHovered ? tag : nil
                                            }
                                        }
                                    }
                                }
                            }
                            .padding(.vertical, 10)
                            .padding(.horizontal, 12)
                            .background(
                                RoundedRectangle(cornerRadius: 6)
                                    .fill(colorScheme == .dark ? 
                                        Color.white.opacity(hoveredTag == tag ? 0.05 : 0) :
                                        Color.black.opacity(hoveredTag == tag ? 0.03 : 0))
                            )
                            .padding(.horizontal, 10)
                            .contentShape(Rectangle())
                            .onHover { isHovered in
                                withAnimation(.easeOut(duration: 0.15)) {
                                    hoveredTag = isHovered ? tag : nil
                                }
                            }
                        }
                    }
                }
                .padding(.vertical, 6)
            }
            .frame(height: 250)
            
            Divider()
            
            // Info message
            HStack(spacing: 6) {
                Image(systemName: "info.circle")
                    .foregroundStyle(theme.secondary.opacity(0.6))
                    .font(.system(size: 11))
                Text("Add tags in Document Details or inside documents")
                    .font(.system(size: 11))
                    .foregroundStyle(theme.secondary.opacity(0.6))
                Spacer()
            }
            .padding(.vertical, 8)
            .padding(.horizontal, 16)
        }
        .background(colorScheme == .dark ? Color(.windowBackgroundColor) : .white)
        .alert("Delete Tag", isPresented: $showDeleteAlert) {
            Button("Cancel", role: .cancel) {
                tagToDelete = nil
            }
            Button("Delete", role: .destructive) {
                if let tag = tagToDelete {
                    deleteTag(tag)
                    tagToDelete = nil
                }
            }
        } message: {
            Text("Are you sure you want to delete this tag? This action cannot be undone.")
        }
        .popover(isPresented: $showColorPicker, arrowEdge: .leading) {
            VStack(spacing: 12) {
                Text("Select Color")
                    .font(.system(size: 13, weight: .semibold))
                    .padding(.top, 12)
                
                VStack(spacing: 8) {
                    ForEach(colorPalette, id: \.name) { colorOption in
                        HStack(spacing: 8) {
                            Circle()
                                .stroke(colorOption.color, lineWidth: 2)
                                .background(
                                    Circle()
                                        .fill(Color(colorScheme == .dark ? .black : .white).opacity(0.1))
                                )
                                .frame(width: 16, height: 16)
                            
                            Text(colorOption.name)
                                .font(.system(size: 13))
                                .foregroundStyle(theme.primary)
                            
                            Spacer()
                        }
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(
                            RoundedRectangle(cornerRadius: 6)
                                .fill(colorScheme == .dark ? 
                                    Color.white.opacity(hoveredColor == colorOption.name ? 0.05 : 0) :
                                    Color.black.opacity(hoveredColor == colorOption.name ? 0.03 : 0))
                        )
                        .contentShape(Rectangle())
                        .onTapGesture {
                            if let tag = selectedTag {
                                colorManager.setColor(colorOption.color, for: tag)
                                showColorPicker = false
                            }
                        }
                        .onHover { isHovered in
                            hoveredColor = isHovered ? colorOption.name : nil
                        }
                    }
                }
                .padding(.horizontal, 4)
                .padding(.bottom, 12)
            }
            .frame(width: 160)
            .background(colorScheme == .dark ? Color(.windowBackgroundColor) : .white)
        }
    }
    
    private func renameTag(from oldName: String, to newName: String) {
        guard oldName != newName, !newName.isEmpty else { return }
        
        // Get documents directory
        guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return }
        
        do {
            // Get all canvas files
            let fileURLs = try FileManager.default.contentsOfDirectory(at: documentsPath, includingPropertiesForKeys: nil)
                .filter { $0.pathExtension == "canvas" }
            
            // Process each document
            for url in fileURLs {
                if let data = try? Data(contentsOf: url),
                   var doc = try? JSONDecoder().decode(Letterspace_CanvasDocument.self, from: data) {
                    // Check if document has the tag
                    if var tags = doc.tags, tags.contains(oldName) {
                        // Replace the old tag with the new one
                        tags = tags.map { $0 == oldName ? newName : $0 }
                        doc.tags = tags
                        
                        // Save updated document
                        if let updatedData = try? JSONEncoder().encode(doc) {
                            try? updatedData.write(to: url)
                        }
                    }
                }
            }
            
            // Update color preference for the new tag name
            if let color = colorManager.colorPreferences[oldName] {
                colorManager.setColor(color, for: newName)
            }
            
            // Notify that documents have been updated
            NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
            
        } catch {
            print("Error accessing documents directory: \(error)")
        }
    }
    
    private func deleteTag(_ tag: String) {
        // Get documents directory
        guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return }
        
        do {
            // Get all canvas files
            let fileURLs = try FileManager.default.contentsOfDirectory(at: documentsPath, includingPropertiesForKeys: nil)
                .filter { $0.pathExtension == "canvas" }
            
            // Process each document
            for url in fileURLs {
                if let data = try? Data(contentsOf: url),
                   var doc = try? JSONDecoder().decode(Letterspace_CanvasDocument.self, from: data) {
                    // Check if document has the tag
                    if var tags = doc.tags, tags.contains(tag) {
                        // Remove the tag
                        tags.removeAll { $0 == tag }
                        doc.tags = tags.isEmpty ? nil : tags
                        
                        // Save updated document
                        if let updatedData = try? JSONEncoder().encode(doc) {
                            try? updatedData.write(to: url)
                        }
                    }
                }
            }
            
            // Notify that documents have been updated
            NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
            
        } catch {
            print("Error accessing documents directory: \(error)")
        }
    }
}

// Update the TrackingTableView class
class TrackingTableView: NSTableView {
    var hoveredRow: Int = -1
    var onHover: ((Int) -> Void)?
    var isDarkMode: Bool = false
    var lastClickTime: Date = Date()
    var lastClickedRow: Int = -1
    var onSingleClick: ((Int) -> Void)?
    var onDoubleClick: ((Int) -> Void)?
    var onLongPress: ((Int) -> Void)?
    var longPressTimer: Timer?
    var coordinator: DocumentTable.Coordinator?
    var parent: DocumentTable?
    var isCalendarPopupOpen: Bool = false
    var isDetailsPopupOpen: Bool = false
    
    // Scroll optimization properties
    private var isAnimatingScroll: Bool = false
    private var needsOptimizedRedraw: Bool = false
    private var lastScrollTime: Date = Date()
    private var scrollThrottleTimer: Timer?
    
    // Add missing properties for context menu actions
    var onPin: ((String) -> Void)?
    var onWIP: ((String) -> Void)?
    var onCalendar: ((String) -> Void)?
    var onDelete: (([String]) -> Void)?
    var onDuplicate: ((String) -> Void)?
    var onDetails: ((String) -> Void)?
    
    override init(frame frameRect: NSRect) {
        super.init(frame: frameRect)
        setupScrollOptimizations()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setupScrollOptimizations()
    }
    
    private func setupScrollOptimizations() {
        // Set layer properties for smoother rendering
        wantsLayer = true
        layerContentsRedrawPolicy = .onSetNeedsDisplay
        
        // Set row drawing optimization
        usesAutomaticRowHeights = false
        
        // Register for frame change notification
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleBoundsChange),
            name: NSView.frameDidChangeNotification,
            object: self.enclosingScrollView?.contentView
        )
    }
    
    @objc private func handleBoundsChange(_ notification: Notification) {
        // Don't process events too frequently
        if Date().timeIntervalSince(lastScrollTime) < 0.016 { // ~60fps
            invalidateScrollThrottleTimer()
            scrollThrottleTimer = Timer.scheduledTimer(withTimeInterval: 0.016, repeats: false) { [weak self] _ in
                self?.lastScrollTime = Date()
                self?.optimizeScrollRedraw()
            }
            return
        }
        
        lastScrollTime = Date()
        optimizeScrollRedraw()
    }
    
    private func optimizeScrollRedraw() {
        // Only redraw visible rows
        needsDisplay = true
    }
    
    private func invalidateScrollThrottleTimer() {
        scrollThrottleTimer?.invalidate()
        scrollThrottleTimer = nil
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
        invalidateScrollThrottleTimer()
    }
    
    override func updateTrackingAreas() {
        super.updateTrackingAreas()
        trackingAreas.forEach { removeTrackingArea($0) }
        addTrackingArea(NSTrackingArea(
            rect: bounds,
            options: [.mouseEnteredAndExited, .mouseMoved, .activeInActiveApp, .inVisibleRect],
            owner: self
        ))
    }
    
    override func mouseEntered(with event: NSEvent) {
        if !isCalendarPopupOpen && !isDetailsPopupOpen {
            updateHoveredRow(with: event)
        }
    }
    
    override func mouseMoved(with event: NSEvent) {
        if !isCalendarPopupOpen && !isDetailsPopupOpen {
            updateHoveredRow(with: event)
        }
    }
    
    override func mouseExited(with event: NSEvent) {
        if !isCalendarPopupOpen && !isDetailsPopupOpen {
            if hoveredRow != -1 {
                let oldRow = hoveredRow
                hoveredRow = -1
                onHover?(-1)
                reloadData(forRowIndexes: IndexSet(integer: oldRow), columnIndexes: IndexSet(integersIn: 0..<numberOfColumns))
            }
        }
    }
    
    private func updateHoveredRow(with event: NSEvent) {
        if !isCalendarPopupOpen && !isDetailsPopupOpen {
            let point = convert(event.locationInWindow, from: nil)
            let newRow = row(at: point)
            if newRow != hoveredRow && newRow < numberOfRows {
                let oldRow = hoveredRow
                hoveredRow = newRow
                onHover?(newRow)
                
                if oldRow >= 0 {
                    reloadData(forRowIndexes: IndexSet(integer: oldRow), columnIndexes: IndexSet(integersIn: 0..<numberOfColumns))
                }
                if newRow >= 0 {
                    reloadData(forRowIndexes: IndexSet(integer: newRow), columnIndexes: IndexSet(integersIn: 0..<numberOfColumns))
                }
            }
        }
    }
    
    override func mouseDown(with event: NSEvent) {
        let point = convert(event.locationInWindow, from: nil)
        let clickedRow = row(at: point)
        
        // Handle Control + Click (same as right-click)
        if event.modifierFlags.contains(.control),
           clickedRow >= 0,
           let coordinator = delegate as? DocumentTable.Coordinator,
           clickedRow < coordinator.documents.count {
            let document = coordinator.documents[clickedRow]
            
            // Create context menu
            let menu = NSMenu()
            menu.items = [
                NSMenuItem(title: "Pin", action: #selector(handlePin(_:)), keyEquivalent: ""),
                NSMenuItem(title: "Mark as WIP", action: #selector(handleWIP(_:)), keyEquivalent: ""),
                NSMenuItem(title: "Add to Calendar", action: #selector(handleCalendar(_:)), keyEquivalent: ""),
                NSMenuItem.separator(),
                NSMenuItem(title: "Create Variation", action: #selector(handleCreateVariation(_:)), keyEquivalent: ""),
                NSMenuItem(title: "Duplicate", action: #selector(handleDuplicate(_:)), keyEquivalent: ""),
                NSMenuItem.separator(),
                NSMenuItem(title: "Delete", action: #selector(handleDelete(_:)), keyEquivalent: "")
            ]
            
            // Set represented objects for menu items
            menu.items[0].representedObject = [document.id]
            menu.items[1].representedObject = [document.id]
            menu.items[2].representedObject = document.id
            menu.items[4].representedObject = document
            menu.items[5].representedObject = document
            menu.items[7].representedObject = [document.id]
            
            // Update menu item states based on current status
            menu.items[0].state = coordinator.pinnedDocuments.contains(document.id) ? .on : .off
            menu.items[1].state = coordinator.wipDocuments.contains(document.id) ? .on : .off
            menu.items[2].state = coordinator.calendarDocuments.contains(document.id) ? .on : .off
            
            NSMenu.popUpContextMenu(menu, with: event, for: self)
            return
        }
        
        // Handle double-click
        if event.clickCount == 2 {
            if clickedRow >= 0,
               let coordinator = delegate as? DocumentTable.Coordinator,
               clickedRow < coordinator.documents.count {
                let document = coordinator.documents[clickedRow]
                coordinator.handleDoubleClick(document)
                return
            }
        }
        
        // Handle single click with modifiers
        if clickedRow >= 0,
           let coordinator = delegate as? DocumentTable.Coordinator,
           clickedRow < coordinator.documents.count {
            let document = coordinator.documents[clickedRow]
            
            if event.modifierFlags.contains(.command) {
                // Command+Click: Toggle selection
                coordinator.handleCommandClick(document)
            } else if event.modifierFlags.contains(.shift) {
                // Shift+Click: Range selection
                coordinator.handleShiftClick(document)
            } else {
                // Normal click: Single selection
                coordinator.handleSingleClick(document)
            }
        }
        
        super.mouseDown(with: event)
    }
    
    override func rightMouseDown(with event: NSEvent) {
        let point = convert(event.locationInWindow, from: nil)
        let clickedRow = row(at: point)
        
        if clickedRow >= 0,
           let coordinator = delegate as? DocumentTable.Coordinator,
           clickedRow < coordinator.documents.count {
            let document = coordinator.documents[clickedRow]
            
            // Create context menu
            let menu = NSMenu()
            menu.items = [
                NSMenuItem(title: "Pin", action: #selector(handlePin(_:)), keyEquivalent: ""),
                NSMenuItem(title: "Mark as WIP", action: #selector(handleWIP(_:)), keyEquivalent: ""),
                NSMenuItem(title: "Add to Calendar", action: #selector(handleCalendar(_:)), keyEquivalent: ""),
                NSMenuItem.separator(),
                NSMenuItem(title: "Create Variation", action: #selector(handleCreateVariation(_:)), keyEquivalent: ""),
                NSMenuItem(title: "Duplicate", action: #selector(handleDuplicate(_:)), keyEquivalent: ""),
                NSMenuItem.separator(),
                NSMenuItem(title: "Delete", action: #selector(handleDelete(_:)), keyEquivalent: "")
            ]
            
            // Set represented objects for menu items
            menu.items[0].representedObject = [document.id]
            menu.items[1].representedObject = [document.id]
            menu.items[2].representedObject = document.id
            menu.items[4].representedObject = document
            menu.items[5].representedObject = document
            menu.items[7].representedObject = [document.id]
            
            // Update menu item states based on current status
            menu.items[0].state = coordinator.pinnedDocuments.contains(document.id) ? .on : .off
            menu.items[1].state = coordinator.wipDocuments.contains(document.id) ? .on : .off
            menu.items[2].state = coordinator.calendarDocuments.contains(document.id) ? .on : .off
            
            NSMenu.popUpContextMenu(menu, with: event, for: self)
        }
        
        super.rightMouseDown(with: event)
    }
    
    override func mouseUp(with event: NSEvent) {
        longPressTimer?.invalidate()
        super.mouseUp(with: event)
    }
    
    // Add the handler methods for context menu actions
    @objc private func handlePin(_ sender: NSMenuItem) {
        if let documentIds = sender.representedObject as? [String] {
            for docId in documentIds {
                onPin?(docId)
            }
        }
    }
    
    @objc private func handleWIP(_ sender: NSMenuItem) {
        if let documentIds = sender.representedObject as? [String] {
            for docId in documentIds {
                onWIP?(docId)
            }
        }
    }
    
    @objc private func handleCalendar(_ sender: NSMenuItem) {
        if let documentId = sender.representedObject as? String {
            onCalendar?(documentId)
        }
    }
    
    @objc private func handleDetails(_ sender: NSMenuItem) {
        if let document = sender.representedObject as? Letterspace_CanvasDocument {
            onDetails?(document.id)
        }
    }
    
    @objc private func handleDuplicate(_ sender: NSMenuItem) {
        if let document = sender.representedObject as? Letterspace_CanvasDocument {
            onDuplicate?(document.id)
        }
    }
    
    @objc private func handleDelete(_ sender: NSMenuItem) {
        if let documentIds = sender.representedObject as? [String] {
            onDelete?(documentIds)
        }
    }
    
    // Add handler for Create Variation
    @objc private func handleCreateVariation(_ sender: NSMenuItem) {
        if let document = sender.representedObject as? Letterspace_CanvasDocument {
            // Check if the document has a valid header image
            let hasValidHeaderImage = document.elements.contains(where: { 
                $0.type == .headerImage && !$0.content.isEmpty 
            })
            
            // Create a new document as a variation
            var newDoc = Letterspace_CanvasDocument(
                title: document.title + " (Variation)",
                subtitle: document.subtitle,
                elements: document.elements,
                id: UUID().uuidString,
                markers: document.markers,
                series: document.series,
                variations: [
                    DocumentVariation(
                        id: UUID(),
                        name: "Original",
                        documentId: document.id,
                        parentDocumentId: document.id,
                        createdAt: Date(),
                        datePresented: document.variations.first?.datePresented,
                        location: document.variations.first?.location
                    )
                ],
                isVariation: true,
                parentVariationId: document.id,
                tags: document.tags,
                isHeaderExpanded: hasValidHeaderImage && document.isHeaderExpanded, // Only expand if original had valid header image
                isSubtitleVisible: document.isSubtitleVisible,
                links: document.links
            )
            
            // Save directly
            newDoc.save()
            
            // Post notifications to update the UI
            NotificationCenter.default.post(
                name: NSNotification.Name("OpenDocument"),
                object: nil,
                userInfo: ["document": newDoc]
            )
            NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
        }
    }
}

struct DocumentTable: NSViewRepresentable {
    // Add defaultColumnOrder at the top of DocumentTable
    private let defaultColumnOrder = ["status", "name", "series", "location", "date", "createdDate", "presentedDate"]
    
    // Add sorting state
    private var currentSortColumn: String = "name"
    private var isAscending: Bool = true
    
    @Binding var documents: [Letterspace_CanvasDocument]
    @Binding var selectedDocuments: Set<String>
    let isSelectionMode: Bool
    let pinnedDocuments: Set<String>
    let wipDocuments: Set<String>
    let calendarDocuments: Set<String>
    let visibleColumns: Set<String>
    let dateFilterType: DateFilterType
    let onPin: (String) -> Void
    let onWIP: (String) -> Void
    let onCalendar: (String) -> Void
    let onOpen: (Letterspace_CanvasDocument) -> Void
    let onShowDetails: (Letterspace_CanvasDocument) -> Void
    let onDelete: ([String]) -> Void
    @Environment(\.colorScheme) var colorScheme
    @Environment(\.themeColors) var theme
    @State private var activeTooltip: (text: String, position: CGPoint)?
    
    // Add helper function for status priority
    private func getStatusPriority(_ doc: Letterspace_CanvasDocument) -> Int {
        var priority = 0
        if pinnedDocuments.contains(doc.id) { priority += 4 }
        if wipDocuments.contains(doc.id) { priority += 2 }
        if calendarDocuments.contains(doc.id) { priority += 1 }
        return priority
    }
    
    init(documents: Binding<[Letterspace_CanvasDocument]>,
         selectedDocuments: Binding<Set<String>>,
         isSelectionMode: Bool,
         pinnedDocuments: Set<String>,
         wipDocuments: Set<String>,
         calendarDocuments: Set<String>,
         visibleColumns: Set<String>,
         dateFilterType: DateFilterType,
         onPin: @escaping (String) -> Void,
         onWIP: @escaping (String) -> Void,
         onCalendar: @escaping (String) -> Void,
         onOpen: @escaping (Letterspace_CanvasDocument) -> Void,
         onShowDetails: @escaping (Letterspace_CanvasDocument) -> Void,
         onDelete: @escaping ([String]) -> Void) {
        self._documents = documents
        self._selectedDocuments = selectedDocuments
        self.isSelectionMode = isSelectionMode
        self.pinnedDocuments = pinnedDocuments
        self.wipDocuments = wipDocuments
        self.calendarDocuments = calendarDocuments
        self.visibleColumns = visibleColumns
        self.dateFilterType = dateFilterType
        self.onPin = onPin
        self.onWIP = onWIP
        self.onCalendar = onCalendar
        self.onOpen = onOpen
        self.onShowDetails = onShowDetails
        self.onDelete = onDelete
    }
    
    // Store reference to the table view
    fileprivate var tableView: NSTableView?
    
    private func deleteSelectedDocuments() {
        let fileManager = FileManager.default
        let documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
        
        print("Attempting to delete \(selectedDocuments.count) documents")
        
        for docId in selectedDocuments {
            if let document = documents.first(where: { $0.id == docId }) {
                let fileURL = documentsURL.appendingPathComponent("\(document.id).canvas")
                print("Deleting document at: \(fileURL)")
                do {
                    try fileManager.removeItem(at: fileURL)
                    print("Successfully deleted document: \(document.title)")
                } catch {
                    print("Error deleting document: \(error)")
                }
            }
        }
        
        // Clear selection
        selectedDocuments.removeAll()
        
        // Post notification that documents have been updated
        NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
    }
    
    mutating func setTableView(_ view: NSTableView) {
        self.tableView = view
    }
    
    func makeNSView(context: Context) -> NSScrollView {
        let scrollView = NSScrollView()
        let customTableView = TrackingTableView()
        customTableView.coordinator = context.coordinator
        customTableView.parent = self
        customTableView.isDarkMode = colorScheme == .dark
        
        // Enhanced scroll view configuration for smooth scrolling
        scrollView.scrollerStyle = .overlay
        scrollView.horizontalScroller?.controlSize = .mini
        scrollView.verticalScroller?.controlSize = .mini
        scrollView.hasHorizontalScroller = true
        scrollView.hasVerticalScroller = true
        scrollView.autohidesScrollers = true
        
        // Configure scroll behavior for smooth scrolling
        scrollView.scrollsDynamically = true
        
        // Customize scrolling physics for smoother experience
        if let verticalScroller = scrollView.verticalScroller {
            verticalScroller.alphaValue = 0.6
            verticalScroller.knobStyle = .dark
            
            // Improved acceleration values
            scrollView.verticalScrollElasticity = .automatic
            scrollView.scrollerInsets = NSEdgeInsets(top: 0, left: 0, bottom: 0, right: 2)
        }
        
        if let horizontalScroller = scrollView.horizontalScroller {
            horizontalScroller.alphaValue = 0.6
            horizontalScroller.knobStyle = .dark
            scrollView.horizontalScrollElasticity = .automatic
        }
        
        // Configure table view
        customTableView.style = .fullWidth
        customTableView.delegate = context.coordinator
        customTableView.dataSource = context.coordinator
        customTableView.usesAlternatingRowBackgroundColors = false
        customTableView.backgroundColor = .clear
        customTableView.enclosingScrollView?.backgroundColor = .clear
        customTableView.selectionHighlightStyle = .regular
        customTableView.intercellSpacing = NSSize(width: 0, height: 4)
        customTableView.rowHeight = 44
        customTableView.wantsLayer = true
        customTableView.enclosingScrollView?.wantsLayer = true
        customTableView.headerView?.wantsLayer = true
        customTableView.headerView?.layer?.backgroundColor = NSColor.clear.cgColor
        
        // Set up context menu handlers
        customTableView.onPin = onPin
        customTableView.onWIP = onWIP
        customTableView.onCalendar = onCalendar
        customTableView.onDetails = { documentId in
            if let document = context.coordinator.documents.first(where: { $0.id == documentId }) {
                onShowDetails(document)
            }
        }
        customTableView.onDuplicate = { documentId in
            if let document = context.coordinator.documents.first(where: { $0.id == documentId }) {
                var newDoc = document
                newDoc.id = UUID().uuidString
                newDoc.title += " (Copy)"
                newDoc.createdAt = Date()
                newDoc.modifiedAt = Date()
                newDoc.save()
                NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
            }
        }
        customTableView.onDelete = { documentIds in
            context.coordinator.selectedDocuments = Set(documentIds)
            deleteSelectedDocuments()
        }
        
        // Add status column
        let statusColumn = NSTableColumn(identifier: NSUserInterfaceItemIdentifier("status"))
        statusColumn.title = "Quick Actions"
        statusColumn.width = 110
        statusColumn.minWidth = 110
        statusColumn.maxWidth = 110
        statusColumn.headerCell.alignment = .left
        statusColumn.headerCell.attributedStringValue = NSAttributedString(
            string: "Quick Actions",
            attributes: [NSAttributedString.Key.paragraphStyle: NSParagraphStyle.leftAligned(withPadding: 8),
                        NSAttributedString.Key.font: NSFont(name: "InterTight-Medium", size: 11)!,
                        NSAttributedString.Key.kern: 0.3])
        statusColumn.headerCell.backgroundColor = .clear  // Set header cell background to clear
        statusColumn.resizingMask = []  // Lock width
        customTableView.addTableColumn(statusColumn)
        
        // Add name column
        let nameColumn = NSTableColumn(identifier: NSUserInterfaceItemIdentifier("name"))
        nameColumn.title = "Name"
        nameColumn.width = ListColumn.name.width
        nameColumn.minWidth = 100
        nameColumn.headerCell.alignment = .left
        nameColumn.headerCell.attributedStringValue = NSAttributedString(
            string: "Name",
            attributes: [NSAttributedString.Key.paragraphStyle: NSParagraphStyle.leftAligned(withPadding: 8),
                        NSAttributedString.Key.font: NSFont(name: "InterTight-Medium", size: 11)!,
                        NSAttributedString.Key.kern: 0.3])
        nameColumn.headerCell.backgroundColor = .clear  // Set header cell background to clear
        nameColumn.resizingMask = []  // Lock width
        customTableView.addTableColumn(nameColumn)
        
        // Configure scroll view
        scrollView.documentView = customTableView
        scrollView.hasVerticalScroller = true
        scrollView.hasHorizontalScroller = true
        scrollView.autohidesScrollers = false
        scrollView.horizontalScrollElasticity = .none
        scrollView.verticalScrollElasticity = .none
        scrollView.backgroundColor = .clear  // Ensure scroll view background is clear
        
        // Ensure all header cells have clear backgrounds
        for column in customTableView.tableColumns {
            column.headerCell.backgroundColor = .clear
        }
        
        // Configure both scrollers to be always visible with legacy style
        if let horizontalScroller = scrollView.horizontalScroller {
            horizontalScroller.controlSize = .regular
            horizontalScroller.scrollerStyle = .legacy
        }
        
        if let verticalScroller = scrollView.verticalScroller {
            verticalScroller.controlSize = .regular
            verticalScroller.scrollerStyle = .legacy
        }
        
        // Set up hover tracking
        customTableView.onHover = { row in
            context.coordinator.hoveredRow = row
            if row >= 0 {
                customTableView.reloadData(forRowIndexes: IndexSet(integer: row), columnIndexes: IndexSet(integersIn: 0..<customTableView.numberOfColumns))
            }
        }
        
        return scrollView
    }
    
    func updateNSView(_ nsView: NSScrollView, context: Context) {
        guard let tableView = nsView.documentView as? NSTableView else { return }
        
        // Update coordinator state with a local copy of documents to avoid state modification during view updates
        let localDocuments = documents
        context.coordinator.documents = localDocuments
        context.coordinator.selectedDocuments = selectedDocuments
        context.coordinator.isSelectionMode = isSelectionMode
        context.coordinator.pinnedDocuments = pinnedDocuments
        context.coordinator.wipDocuments = wipDocuments
        context.coordinator.calendarDocuments = calendarDocuments
        context.coordinator.visibleColumns = visibleColumns
        context.coordinator.dateFilterType = dateFilterType
        context.coordinator.colorScheme = colorScheme
        
        // Use CATransaction to prevent animation during updates
        CATransaction.begin()
        CATransaction.setDisableActions(true)
        
        // Enhanced scroll view performance settings
        if let scrollView = tableView.enclosingScrollView {
            // Configure scrolling behavior for smoother experience
            scrollView.scrollsDynamically = true
            
            // Use optimized scrolling modes
            scrollView.usesPredominantAxisScrolling = true
            scrollView.horizontalScrollElasticity = .automatic
            scrollView.verticalScrollElasticity = .automatic
            
            // Set scroller appearance for better UX
            scrollView.scrollerStyle = .overlay
            scrollView.verticalScroller?.knobStyle = .light
            scrollView.horizontalScroller?.knobStyle = .light
            
            // Configure content view for better scrolling
            let clipView = scrollView.contentView
            clipView.drawsBackground = false
            
            // Set optimized scrolling options
            if #available(macOS 13.0, *) {
                clipView.automaticallyAdjustsContentInsets = true
            }
            
            // Note: Previously used copiesOnScroll but it's deprecated in macOS 11.0+
        }
        
        // Enable responsive scrolling for smooth experience
        tableView.usesAutomaticRowHeights = false
        
        // Set optimized table drawing values
        tableView.tag = 100
        
        // Remove columns that should be hidden
        for column in tableView.tableColumns {
            let columnId = column.identifier.rawValue
            if columnId != "status" && columnId != "name" && !visibleColumns.contains(columnId) {
                tableView.removeTableColumn(column)
            }
        }
        
        // Add or restore columns that should be visible
        for columnId in defaultColumnOrder {
            // Skip status and name columns as they're always present
            if columnId == "status" || columnId == "name" { continue }
            
            // Check if column should be visible
            if visibleColumns.contains(columnId) {
                // Check if column already exists
                if !tableView.tableColumns.contains(where: { $0.identifier.rawValue == columnId }) {
                    let column = NSTableColumn(identifier: NSUserInterfaceItemIdentifier(columnId))
                    column.title = {
                        switch columnId {
                        case "series": return "Series"
                        case "location": return "Location"
                        case "date": return "Modified"
                        case "createdDate": return "Created"
                        case "presentedDate": return "Presented On"
                        default: return ""
                        }
                    }()
                    column.width = {
                        switch columnId {
                        case "series": return ListColumn.series.width(for: documents)
                        case "location": return ListColumn.location.width(for: documents)
                        case "date": return ListColumn.date.width(for: documents)
                        case "createdDate": return ListColumn.createdDate.width(for: documents)
                        case "presentedDate": return ListColumn.presentedDate.width(for: documents)
                        default: return 100
                        }
                    }()
                    column.minWidth = 100
                    column.headerCell.alignment = .left
                    column.headerCell.attributedStringValue = NSAttributedString(
                        string: column.title,
                        attributes: [NSAttributedString.Key.paragraphStyle: NSParagraphStyle.leftAligned(withPadding: 8),
                                   NSAttributedString.Key.font: NSFont(name: "InterTight-Medium", size: 11)!,
                                   NSAttributedString.Key.kern: 0.3])
                    column.resizingMask = .userResizingMask
                    
                    
                    // Find where this column should be inserted based on defaultColumnOrder
                    let targetIndex = defaultColumnOrder.firstIndex(of: columnId) ?? tableView.tableColumns.count
                    let currentIndex = min(targetIndex, tableView.tableColumns.count)
                    
                    // Add the column and move it to the correct position
                    tableView.addTableColumn(column)
                    if currentIndex < tableView.tableColumns.count - 1 {
                        tableView.moveColumn(tableView.tableColumns.count - 1, toColumn: currentIndex)
                    }
                }
            }
        }
        
        // Create a local copy of documents for sorting to avoid modifying state during view updates
        var sortedDocuments = localDocuments
        
        // Sort documents
        sortedDocuments.sort { (doc1, doc2) in
            // Removed unused 'result' variable
            
            switch self.currentSortColumn {
            case "status":
                let status1 = self.getStatusPriority(doc1)
                let status2 = self.getStatusPriority(doc2)
                if status1 != status2 {
                    return self.isAscending ? status1 < status2 : status1 > status2
                }
                // Fall through to name sorting if status is equal
                let title1 = doc1.title.isEmpty ? "Untitled" : doc1.title
                let title2 = doc2.title.isEmpty ? "Untitled" : doc2.title
                return self.isAscending ? 
                    title1.localizedCompare(title2) == .orderedAscending :
                    title1.localizedCompare(title2) == .orderedDescending
                
            case "name":
                let title1 = doc1.title.isEmpty ? "Untitled" : doc1.title
                let title2 = doc2.title.isEmpty ? "Untitled" : doc2.title
                return self.isAscending ? 
                    title1.localizedCompare(title2) == .orderedAscending :
                    title1.localizedCompare(title2) == .orderedDescending
                
            case "series":
                let series1 = doc1.series?.name ?? ""
                let series2 = doc2.series?.name ?? ""
                return self.isAscending ? 
                    series1.localizedCompare(series2) == .orderedAscending :
                    series1.localizedCompare(series2) == .orderedDescending
                
            case "location":
                let loc1 = doc1.variations.first?.location ?? ""
                let loc2 = doc2.variations.first?.location ?? ""
                return self.isAscending ? 
                    loc1.localizedCompare(loc2) == .orderedAscending :
                    loc1.localizedCompare(loc2) == .orderedDescending
                
            case "date":
                return self.isAscending ? 
                    doc1.modifiedAt < doc2.modifiedAt :
                    doc1.modifiedAt > doc2.modifiedAt
                
            case "createdDate":
                return self.isAscending ? 
                    doc1.createdAt < doc2.createdAt :
                    doc1.createdAt > doc2.createdAt
                
            case "presentedDate":
                let date1 = doc1.variations.first?.datePresented
                let date2 = doc2.variations.first?.datePresented
                if date1 == nil && date2 == nil {
                    return false  // Keep relative order unchanged
                } else if date1 == nil {
                    return !self.isAscending  // Put nil dates at the end
                } else if date2 == nil {
                    return self.isAscending  // Put nil dates at the end
                } else {
                    return self.isAscending ? date1! < date2! : date1! > date2!
                }
                
            default:
                // Default to sorting by modified date
                return self.isAscending ? 
                    doc1.modifiedAt < doc2.modifiedAt :
                    doc1.modifiedAt > doc2.modifiedAt
            }
            
        }
        
        // Update the coordinator with the sorted documents
        context.coordinator.documents = sortedDocuments
        
        // Reload the table view with sorted documents
        tableView.reloadData()
        
        // Commit the transaction
        CATransaction.commit()
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, NSTableViewDataSource, NSTableViewDelegate {
        var parent: DocumentTable
        var documents: [Letterspace_CanvasDocument]
        var selectedDocuments: Set<String>
        var isSelectionMode: Bool
        var pinnedDocuments: Set<String>
        var wipDocuments: Set<String>
        var calendarDocuments: Set<String>
        var visibleColumns: Set<String>
        var dateFilterType: DateFilterType
        var hoveredRow: Int = -1
        var colorScheme: ColorScheme
        var tableView: NSTableView?  // Make this optional
        private var lastSelectedRow: Int?  // Add this to track last selected row for shift+click
        
        // Add helper function for status priority
        private func getStatusPriority(_ doc: Letterspace_CanvasDocument) -> Int {
            var priority = 0
            if pinnedDocuments.contains(doc.id) { priority += 4 }
            if wipDocuments.contains(doc.id) { priority += 2 }
            if calendarDocuments.contains(doc.id) { priority += 1 }
            return priority
        }
        
        // Update default sort to name column and ascending order
        private var currentSortColumn: String = "name"
        private var isAscending: Bool = true
        
        init(_ parent: DocumentTable) {
            self.parent = parent
            self.documents = parent.documents.sorted {
                let title1 = $0.title.isEmpty ? "Untitled" : $0.title
                let title2 = $1.title.isEmpty ? "Untitled" : $1.title
                return title1.localizedCompare(title2) == .orderedAscending
            }
            self.selectedDocuments = parent.selectedDocuments
            self.isSelectionMode = parent.isSelectionMode
            self.pinnedDocuments = parent.pinnedDocuments
            self.wipDocuments = parent.wipDocuments
            self.calendarDocuments = parent.calendarDocuments
            self.visibleColumns = parent.visibleColumns
            self.dateFilterType = parent.dateFilterType
            self.colorScheme = parent.colorScheme
            super.init()
        }
        
        func numberOfRows(in tableView: NSTableView) -> Int {
            return documents.count
        }
        
        func tableView(_ tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int) -> NSView? {
            let document = documents[row]
            let isSelected = selectedDocuments.contains(document.id)
            let isHovered = row == hoveredRow
            
            // Get the background color based on state - restore hover effect
            let backgroundColor: NSColor? = {
                if isSelected {
                    return NSColor(parent.theme.accent.opacity(0.1))  // Restore accent color for selected rows
                } else if isHovered {
                    return NSColor(parent.theme.accent.opacity(0.1))  // Accent color for hover
                }
                return nil
            }()
            
            // Create cell views based on column identifier
            switch tableColumn?.identifier.rawValue {
                case "status":
                    let statusView = DocumentStatusView(
                        document: document,
                        pinnedDocuments: pinnedDocuments,
                        wipDocuments: wipDocuments,
                        calendarDocuments: calendarDocuments,
                        onPin: parent.onPin,
                        onWIP: parent.onWIP,
                        onCalendar: parent.onCalendar,
                        onOpen: parent.onOpen,
                        onShowDetails: parent.onShowDetails,
                        isHovering: isHovered
                    )
                    let cell = NSHostingView(rootView: statusView)
                    cell.wantsLayer = true
                    if let bgColor = backgroundColor {
                        cell.layer?.backgroundColor = bgColor.cgColor
                    } else {
                        cell.layer?.backgroundColor = NSColor.clear.cgColor
                    }
                    return cell
                    
                case "name":
                    let cell = NSHostingView(rootView: 
                        HStack(spacing: 12) {
                            Image(systemName: "doc.text")
                                .font(.system(size: 14))
                                .foregroundStyle(colorScheme == .dark ? .white : Color(.sRGB, white: 0.3))
                            
                            HStack(spacing: 4) {
                                Text(document.title.isEmpty ? "Untitled" : document.title)
                                    .font(.custom("InterTight-Regular", size: 13))
                                    .tracking(0.3)
                                    .foregroundStyle(colorScheme == .dark ? .white : Color(.sRGB, white: 0.3))
                                    .lineLimit(1)
                                    .truncationMode(.tail)
                                
                                if !document.subtitle.isEmpty {
                                    Text("•")
                                        .font(.custom("InterTight-Regular", size: 11))
                                        .foregroundStyle(colorScheme == .dark ? Color(.sRGB, white: 0.6) : Color(.sRGB, white: 0.5))
                                    Text(document.subtitle)
                                        .font(.custom("InterTight-Regular", size: 11))
                                        .tracking(0.5)
                                        .foregroundStyle(colorScheme == .dark ? Color(.sRGB, white: 0.6) : Color(.sRGB, white: 0.5))
                                        .lineLimit(1)
                                }
                            }
                        }
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.horizontal, 8))
                    cell.wantsLayer = true
                    if let bgColor = backgroundColor {
                        cell.layer?.backgroundColor = bgColor.cgColor
                    } else {
                        cell.layer?.backgroundColor = NSColor.clear.cgColor
                    }
                    return cell
                    
                case "series":
                    let cell = NSHostingView(rootView: Text(document.series?.name ?? "")
                        .font(.custom("InterTight-Regular", size: 11))
                        .tracking(0.5)
                        .foregroundStyle(colorScheme == .dark ? .white.opacity(0.8) : Color(.sRGB, white: 0.3))
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.horizontal, 8))
                    cell.wantsLayer = true
                    if let bgColor = backgroundColor {
                        cell.layer?.backgroundColor = bgColor.cgColor
                    } else {
                        cell.layer?.backgroundColor = NSColor.clear.cgColor
                    }
                    return cell
                    
                case "location":
                    let cell = NSHostingView(rootView: Text(document.variations.first?.location ?? "")
                        .font(.custom("InterTight-Regular", size: 11))
                        .tracking(0.5)
                        .foregroundStyle(colorScheme == .dark ? .white.opacity(0.8) : Color(.sRGB, white: 0.3))
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.horizontal, 8))
                    cell.wantsLayer = true
                    if let bgColor = backgroundColor {
                        cell.layer?.backgroundColor = bgColor.cgColor
                    } else {
                        cell.layer?.backgroundColor = NSColor.clear.cgColor
                    }
                    return cell
                    
                case "date":
                    let cell = NSHostingView(rootView: Text(formatDate(document.modifiedAt))
                        .font(.custom("InterTight-Regular", size: 11))
                        .tracking(0.5)
                        .foregroundStyle(colorScheme == .dark ? .white.opacity(0.8) : Color(.sRGB, white: 0.3))
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.horizontal, 8))
                    cell.wantsLayer = true
                    if let bgColor = backgroundColor {
                        cell.layer?.backgroundColor = bgColor.cgColor
                    } else {
                        cell.layer?.backgroundColor = NSColor.clear.cgColor
                    }
                    return cell
                    
                case "createdDate":
                    let cell = NSHostingView(rootView: Text(formatDate(document.createdAt))
                        .font(.custom("InterTight-Regular", size: 11))
                        .tracking(0.5)
                        .foregroundStyle(colorScheme == .dark ? .white.opacity(0.8) : Color(.sRGB, white: 0.3))
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.horizontal, 8))
                    cell.wantsLayer = true
                    if let bgColor = backgroundColor {
                        cell.layer?.backgroundColor = bgColor.cgColor
                    } else {
                        cell.layer?.backgroundColor = NSColor.clear.cgColor
                    }
                    return cell
                    
                case "presentedDate":
                    let presentedDateText = document.variations.first?.datePresented != nil ? 
                        formatDate(document.variations.first!.datePresented!) : ""
                    let cell = NSHostingView(rootView: Text(presentedDateText)
                        .font(.custom("InterTight-Regular", size: 11))
                        .tracking(0.5)
                        .foregroundStyle(colorScheme == .dark ? .white.opacity(0.8) : Color(.sRGB, white: 0.3))
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.horizontal, 8))
                    cell.wantsLayer = true
                    if let bgColor = backgroundColor {
                        cell.layer?.backgroundColor = bgColor.cgColor
                    } else {
                        cell.layer?.backgroundColor = NSColor.clear.cgColor
                    }
                    return cell
                    
                default:
                    return nil
            }
        }
        
        private func formatDate(_ date: Date) -> String {
            let calendar = Calendar.current
            let timeFormatter = DateFormatter()
            timeFormatter.dateFormat = "h:mm a"
            
            if calendar.isDateInToday(date) {
                return "Today, \(timeFormatter.string(from: date))"
            }
            
            let formatter = DateFormatter()
            formatter.dateStyle = .medium
            formatter.timeStyle = .none
            return formatter.string(from: date)
        }
        
        func handleSingleClick(_ document: Letterspace_CanvasDocument) {
            // Clear existing selection and select only the clicked document
            selectedDocuments = Set([document.id])
            
            // Update last selected row for potential shift+click
            if let row = documents.firstIndex(where: { $0.id == document.id }) {
                lastSelectedRow = row
            }
            
            // Update parent's selection state
            parent.selectedDocuments = selectedDocuments
            
            // Force immediate update of the table view
            if let tableView = self.tableView {
                tableView.reloadData()
            }
        }
        
        func handleDoubleClick(_ document: Letterspace_CanvasDocument) {
            parent.onOpen(document)
        }
        
        func handleLongPress(_ document: Letterspace_CanvasDocument) {
            isSelectionMode = true
            selectedDocuments.insert(document.id)
            parent.selectedDocuments = selectedDocuments
        }
        
        // Remove selection handling from delegate
        func tableView(_ tableView: NSTableView, shouldSelectRow row: Int) -> Bool {
            return false
        }
        
        func handleDetails(_ document: Letterspace_CanvasDocument) {
            parent.onShowDetails(document)
        }
        
        func tableView(_ tableView: NSTableView, didClick tableColumn: NSTableColumn) {
            guard let columnId = tableColumn.identifier.rawValue as String? else { return }
            
            // Toggle sort direction if clicking the same column
            if currentSortColumn == columnId {
                isAscending.toggle()
            } else {
                currentSortColumn = columnId
                isAscending = true
            }
            
            // Update all column headers
            for column in tableView.tableColumns {
                let baseTitle: String
                switch column.identifier.rawValue {
                case "status": baseTitle = "Quick Actions"
                case "name": baseTitle = "Name"
                case "series": baseTitle = "Series"
                case "location": baseTitle = "Location"
                case "date": baseTitle = "Modified"
                case "createdDate": baseTitle = "Created"
                case "presentedDate": baseTitle = "Presented On"
                default: baseTitle = column.title
                }
                
                let isCurrentSortColumn = currentSortColumn == column.identifier.rawValue
                let headerText = isCurrentSortColumn ? "\(baseTitle) \(isAscending ? "↑" : "↓")" : baseTitle
                
                column.headerCell.attributedStringValue = NSAttributedString(
                    string: headerText,
                    attributes: [NSAttributedString.Key.paragraphStyle: NSParagraphStyle.leftAligned(withPadding: 8),
                               NSAttributedString.Key.font: NSFont(name: "InterTight-Medium", size: 11)!,
                               NSAttributedString.Key.kern: 0.3])
            }
            
            // Sort only the coordinator's documents array
            documents.sort { (doc1, doc2) in
                switch currentSortColumn {
                case "status":
                    let status1 = self.getStatusPriority(doc1)
                    let status2 = self.getStatusPriority(doc2)
                    if status1 != status2 {
                        return self.isAscending ? status1 < status2 : status1 > status2
                    }
                    // Fall through to name sorting if status is equal
                    let title1 = doc1.title.isEmpty ? "Untitled" : doc1.title
                    let title2 = doc2.title.isEmpty ? "Untitled" : doc2.title
                    return self.isAscending ? 
                        title1.localizedCompare(title2) == .orderedAscending :
                        title1.localizedCompare(title2) == .orderedDescending
                    
                case "name":
                    let title1 = doc1.title.isEmpty ? "Untitled" : doc1.title
                    let title2 = doc2.title.isEmpty ? "Untitled" : doc2.title
                    return self.isAscending ? 
                        title1.localizedCompare(title2) == .orderedAscending :
                        title1.localizedCompare(title2) == .orderedDescending
                    
                case "series":
                    let series1 = doc1.series?.name ?? ""
                    let series2 = doc2.series?.name ?? ""
                    return self.isAscending ? 
                        series1.localizedCompare(series2) == .orderedAscending :
                        series1.localizedCompare(series2) == .orderedDescending
                    
                case "location":
                    let loc1 = doc1.variations.first?.location ?? ""
                    let loc2 = doc2.variations.first?.location ?? ""
                    return self.isAscending ? 
                        loc1.localizedCompare(loc2) == .orderedAscending :
                        loc1.localizedCompare(loc2) == .orderedDescending
                    
                case "date":
                    return self.isAscending ? 
                        doc1.modifiedAt < doc2.modifiedAt :
                        doc1.modifiedAt > doc2.modifiedAt
                    
                case "createdDate":
                    return self.isAscending ? 
                        doc1.createdAt < doc2.createdAt :
                        doc1.createdAt > doc2.createdAt
                    
                case "presentedDate":
                    let date1 = doc1.variations.first?.datePresented
                    let date2 = doc2.variations.first?.datePresented
                    if date1 == nil && date2 == nil {
                        return false  // Keep relative order unchanged
                    } else if date1 == nil {
                        return !self.isAscending  // Put nil dates at the end
                    } else if date2 == nil {
                        return self.isAscending  // Put nil dates at the end
                    } else {
                        return self.isAscending ? date1! < date2! : date1! > date2!
                    }
                    
                default:
                    // Default to sorting by modified date
                    return self.isAscending ? 
                        doc1.modifiedAt < doc2.modifiedAt :
                        doc1.modifiedAt > doc2.modifiedAt
                }
            }
            
            // Reload the table view with sorted documents
            tableView.reloadData()
        }
        
        func handleCommandClick(_ document: Letterspace_CanvasDocument) {
            // Toggle selection for the clicked document
            if selectedDocuments.contains(document.id) {
                selectedDocuments.remove(document.id)
            } else {
                selectedDocuments.insert(document.id)
            }
            
            // Update last selected row for potential shift+click
            if let row = documents.firstIndex(where: { $0.id == document.id }) {
                lastSelectedRow = row
            }
            
            // Update parent's selection state
            parent.selectedDocuments = selectedDocuments
            
            // Force immediate update of the table view
            if let tableView = self.tableView {
                tableView.reloadData()
            }
        }
        
        func handleShiftClick(_ document: Letterspace_CanvasDocument) {
            guard let currentRow = documents.firstIndex(where: { $0.id == document.id }) else { return }
            
            // If there's no last selected row or no current selection, treat as single click
            if lastSelectedRow == nil || selectedDocuments.isEmpty {
                handleSingleClick(document)
                return
            }
            
            // Calculate range
            let startRow = min(lastSelectedRow!, currentRow)
            let endRow = max(lastSelectedRow!, currentRow)
            
            // Add all documents in range to selection
            for row in startRow...endRow {
                selectedDocuments.insert(documents[row].id)
            }
            
            // Update parent's selection state
            parent.selectedDocuments = selectedDocuments
            
            // Force immediate update of the table view
            if let tableView = self.tableView {
                tableView.reloadData()
            }
        }
    }
}

// Helper views for table cells
struct DocumentStatusView: View {
    let document: Letterspace_CanvasDocument
    let pinnedDocuments: Set<String>
    let wipDocuments: Set<String>
    let calendarDocuments: Set<String>
    let onPin: (String) -> Void
    let onWIP: (String) -> Void
    let onCalendar: (String) -> Void
    let onOpen: (Letterspace_CanvasDocument) -> Void
    let onShowDetails: (Letterspace_CanvasDocument) -> Void
    let isHovering: Bool
    @Environment(\.themeColors) var theme
    @State private var showDetailsPopover = false
    @State private var showCalendarContext: Bool = false
    @State private var pinHover = false
    @State private var wipHover = false
    @State private var calendarHover = false
    @State private var detailsHover = false
    @State private var isPopoverInteracting = false
    
    var body: some View {
        ZStack {
            // Main content
            HStack(spacing: 8) {
                if isHovering || isPopoverInteracting {
                    // Group all interactive buttons in one HStack
                    HStack(spacing: 0) {
                        // Pin button
                        Button(action: {
                            onPin(document.id)
                        }) {
                            Image(systemName: "pin.fill")
                                .font(.system(size: 13))
                                .foregroundStyle(pinnedDocuments.contains(document.id) ? .green : theme.secondary.opacity(0.7))
                                .frame(width: 24, height: 24)
                                .background(
                                    Circle()
                                        .fill(theme.accent.opacity(pinHover ? 0.2 : 0))
                                )
                        }
                        .buttonStyle(.plain)
                        .help("Pin Document")
                        .onHover { hovering in
                            pinHover = hovering
                        }
                        .allowsHitTesting(!showCalendarContext && !showDetailsPopover)
                        
                        // WIP button
                        Button(action: { onWIP(document.id) }) {
                            Image(systemName: "clock.fill")
                                .font(.system(size: 13))
                                .foregroundStyle(wipDocuments.contains(document.id) ? .orange : theme.secondary.opacity(0.7))
                                .frame(width: 24, height: 24)
                                .background(
                                    Circle()
                                        .fill(theme.accent.opacity(wipHover ? 0.2 : 0))
                                )
                        }
                        .buttonStyle(.plain)
                        .help("Mark as Work in Progress")
                        .onHover { hovering in
                            wipHover = hovering
                        }
                        .allowsHitTesting(!showCalendarContext && !showDetailsPopover)
                        
                        // Calendar button
                        Button(action: {
                            showCalendarContext = true
                            DispatchQueue.main.async {
                                if let window = NSApp.windows.first(where: { $0.isKeyWindow }),
                                   let contentView = window.contentView,
                                   let tableView = contentView.descendantViews.first(where: { $0 is TrackingTableView }) as? TrackingTableView {
                                    tableView.isCalendarPopupOpen = true
                                }
                            }
                        }) {
                            Image(systemName: "calendar")
                                .font(.system(size: 13))
                                .foregroundStyle(calendarDocuments.contains(document.id) ? .blue : theme.secondary.opacity(0.7))
                                .frame(width: 24, height: 24)
                                .background(
                                    Circle()
                                        .fill(theme.accent.opacity(calendarHover || showCalendarContext ? 0.2 : 0))
                                )
                        }
                        .buttonStyle(.plain)
                        .help("Schedule Document")
                        .onHover { hovering in
                            calendarHover = hovering
                        }
                        .allowsHitTesting(!showDetailsPopover)
                        .popover(isPresented: $showCalendarContext, arrowEdge: .trailing) {
                            CalendarContextMenu(
                                document: document,
                                showScheduleSheet: $showCalendarContext,
                                onCalendar: onCalendar
                            )
                            .onDisappear {
                                DispatchQueue.main.async {
                                    if let window = NSApp.windows.first(where: { $0.isKeyWindow }),
                                       let contentView = window.contentView,
                                       let tableView = contentView.descendantViews.first(where: { $0 is TrackingTableView }) as? TrackingTableView {
                                        tableView.isCalendarPopupOpen = false
                                    }
                                }
                            }
                        }
                        
                        // Details button
                        Button(action: {
                            showDetailsPopover = true
                            DispatchQueue.main.async {
                                if let window = NSApp.windows.first(where: { $0.isKeyWindow }),
                                   let contentView = window.contentView,
                                   let tableView = contentView.descendantViews.first(where: { $0 is TrackingTableView }) as? TrackingTableView {
                                    tableView.isDetailsPopupOpen = true
                                }
                            }
                        }) {
                            Image(systemName: "info.circle")
                                .font(.system(size: 13))
                                .foregroundStyle(theme.secondary.opacity(0.7))
                                .frame(width: 24, height: 24)
                                .background(
                                    Circle()
                                        .fill(theme.accent.opacity(detailsHover || showDetailsPopover ? 0.2 : 0))
                                )
                        }
                        .buttonStyle(.plain)
                        .help("Details")
                        .onHover { hovering in
                            detailsHover = hovering
                        }
                        .allowsHitTesting(!showCalendarContext)
                        .popover(isPresented: $showDetailsPopover, arrowEdge: .trailing) {
                            DocumentDetailsCard(document: .constant(document))
                                .frame(width: 400, height: 600)
                                .onDisappear {
                                    DispatchQueue.main.async {
                                        if let window = NSApp.windows.first(where: { $0.isKeyWindow }),
                                           let contentView = window.contentView,
                                           let tableView = contentView.descendantViews.first(where: { $0 is TrackingTableView }) as? TrackingTableView {
                                            tableView.isDetailsPopupOpen = false
                                        }
                                    }
                                }
                        }
                    }
                } else {
                    // Show status indicators when not hovering
                    Spacer()
                    HStack(spacing: 3) {
                        if pinnedDocuments.contains(document.id) {
                            Circle()
                                .fill(Color.green)
                                .frame(width: 7, height: 7)
                        }
                        if wipDocuments.contains(document.id) {
                            Circle()
                                .fill(Color.orange)
                                .frame(width: 7, height: 7)
                        }
                        if calendarDocuments.contains(document.id) {
                            Circle()
                                .fill(Color.blue)
                                .frame(width: 7, height: 7)
                        }
                    }
                    Spacer()
                }
            }
            .frame(width: 100)
            .padding(.horizontal, 4)
            .contentShape(Rectangle())
            
            // Overlay to block interactions when popup is open
            if showCalendarContext {
                Color.clear
                    .contentShape(Rectangle())
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .allowsHitTesting(true)
            }
        }
    }
}

struct DocumentNameView: View {
    let document: Letterspace_CanvasDocument
    @Environment(\.themeColors) var theme
    
    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: "doc.text")
                .font(.system(size: 14))
                .foregroundStyle(theme.primary)
                .frame(width: 20)
            
            HStack(spacing: 4) {
                Text(document.title.isEmpty ? "Untitled" : document.title)
                    .font(.system(size: 13))
                    .foregroundStyle(theme.primary)
                    .lineLimit(1)
                
                if !document.subtitle.isEmpty {
                    Text("•")
                        .font(.system(size: 13))
                        .foregroundStyle(theme.secondary)
                    Text(document.subtitle)
                        .font(.system(size: 13))
                        .foregroundStyle(theme.secondary)
                        .lineLimit(1)
                }
            }
            
            Spacer()
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(.leading, 8)
    }
}

extension NSParagraphStyle {
    static func leftAligned(withPadding padding: CGFloat) -> NSParagraphStyle {
        let style = NSMutableParagraphStyle()
        style.alignment = .left
        style.headIndent = padding
        style.firstLineHeadIndent = padding
        return style
    }
} 

class DashboardViewModel: ObservableObject {
    @Published var folders: [Folder] = [
        Folder(id: UUID(), name: "Sermons", isEditing: false),
        Folder(id: UUID(), name: "Bible Studies", isEditing: false),
        Folder(id: UUID(), name: "Notes", isEditing: false),
        Folder(id: UUID(), name: "Archive", isEditing: false)
    ]
    @Published var folderSwipeOffsets: [UUID: CGFloat] = [:]
    
    func resetSwipeOffset(for folderId: UUID) {
        folderSwipeOffsets[folderId] = 0
    }
    
    func updateSwipeOffset(for folderId: UUID, offset: CGFloat) {
        // Limit the offset to -60 (width of delete button) to 0
        folderSwipeOffsets[folderId] = max(-60, min(0, offset))
    }
    
    func saveFolders() {
        if let encoded = try? JSONEncoder().encode(folders) {
            UserDefaults.standard.set(encoded, forKey: "SavedFolders")
        }
    }
}

private struct PinnedSection: View {
    let documents: [Letterspace_CanvasDocument]
    let pinnedDocuments: Set<String>
    @Binding var document: Letterspace_CanvasDocument
    @Binding var sidebarMode: RightSidebar.SidebarMode
    @Binding var isRightSidebarVisible: Bool
    @State private var scrollOffset: CGFloat = 0
    @State private var shouldFlashScroll = false
    @Environment(\.themeColors) var theme
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {  // Restored to 12
            HStack(spacing: 8) {
                Image(systemName: "pin.fill")
                    .font(.system(size: 14))
                    .foregroundStyle(theme.primary)
                Text("Pinned")
                    .font(.custom("InterTight-Medium", size: 16))
                    .foregroundStyle(theme.primary)
            }
            .padding(.leading, 4)
            
            // Add divider
            Rectangle()
                .fill(Color(.separatorColor))
                .frame(height: 1)
                .padding(.vertical, 4)
            
            ScrollView(.vertical, showsIndicators: true) {
                GeometryReader { proxy in
                    Color.clear.preference(
                        key: ScrollOffsetPreferenceKey.self,
                        value: proxy.frame(in: .named("pinnedScroll")).minY
                    )
                }
                .frame(height: 0)
                
                LazyVStack(spacing: 6) {  // Reduced from 8 to 6
                    let pinnedDocs = documents.filter { pinnedDocuments.contains($0.id) }
                    if pinnedDocs.isEmpty {
                        Text("No pinned documents")
                            .font(.system(size: 13))
                            .foregroundColor(theme.secondary)
                            .padding(.horizontal, 4)
                    } else {
                        ForEach(pinnedDocs, id: \.id) { doc in
                            PinnedDocumentButton(
                                document: doc,
                                action: {
                                    // Using notification to open document for better performance
                                    // This will use the same optimized path as All Documents section
                                    NotificationCenter.default.post(
                                        name: NSNotification.Name("OpenDocument"),
                                        object: nil,
                                        userInfo: ["documentId": doc.id]
                                    )
                                },
                                pinnedDocuments: .constant(pinnedDocuments)
                            )
                        }
                    }
                }
                .padding(.horizontal, 4)
                .padding(.top, -2)  // Added negative top padding to raise content up
            }
            .overlay(alignment: .bottom) {
                if scrollOffset > 0 {
                    LinearGradient(
                        gradient: Gradient(colors: [
                            colorScheme == .dark ? Color(.sRGB, white: 0.15, opacity: 0) : .white.opacity(0),
                            colorScheme == .dark ? Color(.sRGB, white: 0.15) : .white
                        ]),
                        startPoint: .top,
                        endPoint: .bottom
                    )
                    .frame(height: 24)
                }
            }
            .coordinateSpace(name: "pinnedScroll")
            .onPreferenceChange(ScrollOffsetPreferenceKey.self) { value in
                scrollOffset = -value
            }
            .customScroll(shouldFlash: shouldFlashScroll)
            .frame(height: 137)  // Reduced from 157
        }
        .padding(EdgeInsets(top: 20, leading: 24, bottom: 20, trailing: 24))  // Reduced vertical padding from 24 to 20
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(colorScheme == .dark ? Color(.sRGB, white: 0.12) : .white)
        )
        .clipShape(RoundedRectangle(cornerRadius: 12))
        .shadow(
            color: colorScheme == .dark ? .black.opacity(0.17) : .black.opacity(0.07),  // Updated from 0.15/0.05 to 0.17/0.07
            radius: 8,
            x: 0,
            y: 1
        )
    }
}

private struct WIPSection: View {
    let documents: [Letterspace_CanvasDocument]
    let wipDocuments: Set<String>
    @Binding var document: Letterspace_CanvasDocument
    @Binding var sidebarMode: RightSidebar.SidebarMode
    @Binding var isRightSidebarVisible: Bool
    @Environment(\.themeColors) var theme
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {  // Using 12 spacing to match PinnedSection
            HStack(spacing: 8) {
                Image(systemName: "clock.badge.checkmark")
                    .font(.system(size: 14))
                    .foregroundStyle(theme.primary)
                Text("Work in Progress")
                    .font(.custom("InterTight-Medium", size: 16))
                    .foregroundStyle(theme.primary)
            }
            .padding(.leading, 4)
            
            // Add divider
            Rectangle()
                .fill(Color(.separatorColor))
                .frame(height: 1)
                .padding(.vertical, 4)
            
            ScrollView(.vertical, showsIndicators: true) {
                // Add a zero-height GeometryReader to match PinnedSection structure
                GeometryReader { _ in
                    Color.clear
                }
                .frame(height: 0)
                
                LazyVStack(spacing: 6) {  // Using 6 spacing to match PinnedSection
                    let wipDocs = documents.filter { wipDocuments.contains($0.id) }
                    if wipDocs.isEmpty {
                        Text("No WIP documents")
                            .font(.system(size: 13))
                            .foregroundStyle(theme.secondary)
                            .padding(.horizontal, 4)
                    } else {
                        ForEach(wipDocs, id: \.id) { doc in
                            WIPDocumentButton(
                                document: doc,
                                action: {
                                    // Using notification to open document for better performance
                                    // This will use the same optimized path as All Documents section
                                    NotificationCenter.default.post(
                                        name: NSNotification.Name("OpenDocument"),
                                        object: nil,
                                        userInfo: ["documentId": doc.id]
                                    )
                                }
                            )
                        }
                    }
                }
                .padding(.horizontal, 4)
                .padding(.top, -2)  // Negative padding to exactly match PinnedSection
            }
            .customScroll(shouldFlash: false)  // Added customScroll to match PinnedSection
        }
        .padding(EdgeInsets(top: 20, leading: 24, bottom: 20, trailing: 24))
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(colorScheme == .dark ? Color(.sRGB, white: 0.12) : .white)
        )
        .clipShape(RoundedRectangle(cornerRadius: 12))
        .shadow(
            color: colorScheme == .dark ? .black.opacity(0.17) : .black.opacity(0.07),
            radius: 8,
            x: 0,
            y: 1
        )
    }
}

private struct CalendarDayView: View {
    let day: Int
    let isCurrentMonth: Bool
    let isSelected: Bool
    let hasScheduledItems: Bool
    let hoveredDay: Int?
    let documents: [Letterspace_CanvasDocument]
    let calendarDocuments: Set<String>
    let date: Date
    let onSelect: (CGRect) -> Void
    let onHover: (Bool) -> Void
    @Environment(\.themeColors) var theme
    @Environment(\.colorScheme) var colorScheme
    
    private var scheduledDocuments: [ScheduledDocument] {
        let calendar = Calendar.current
        let scheduledFromSchedules = documents.filter { calendarDocuments.contains($0.id) }
            .compactMap { doc -> [ScheduledDocument]? in
                doc.schedules.filter { schedule in
                    schedule.isScheduledFor(date: date)
                }
            }
            .flatMap { $0 }
            .sorted { $0.startDate < $1.startDate }
        
        // Also check for documents with datePresented matching this date
        // Create virtual ScheduledDocument entries for presentations
        let presentedDocuments = documents.filter { calendarDocuments.contains($0.id) }
            .flatMap { doc -> [ScheduledDocument] in
                doc.variations.compactMap { variation -> ScheduledDocument? in
                    if let presentedDate = variation.datePresented,
                       calendar.isDate(date, equalTo: presentedDate, toGranularity: .day) {
                        // Create a virtual ScheduledDocument for this presentation
                        return ScheduledDocument(
                            documentId: doc.id,
                            serviceType: .special, // Default to special service type
                            startDate: presentedDate,
                            notes: "Presentation" + (variation.location != nil ? " at \(variation.location!)" : "")
                        )
                    }
                    return nil
                }
            }
        
        // Combine and sort both types of documents
        return (scheduledFromSchedules + presentedDocuments)
            .sorted { $0.startDate < $1.startDate }
    }
    
    var body: some View {
        GeometryReader { geometry in
            Button(action: {
                if isCurrentMonth {
                    onSelect(geometry.frame(in: .global))
                }
            }) {
        Text("\(day)")
                    .font(.custom("InterTight-Regular", size: 10))
            .tracking(0.5)
                    // Change from medium to bold
                    .fontWeight(isSelected ? .bold : .regular)
            .foregroundStyle(isCurrentMonth ? theme.primary : theme.secondary.opacity(0.3))
                    .frame(width: 18, height: 18)
            .frame(maxWidth: .infinity)
            .background(
                ZStack {
                    // Filled background for days with scheduled items (now includes selected dates too)
                Circle()
                        .fill(hasScheduledItems ? theme.accent.opacity(0.2) : Color.clear)
                    
                    // Background for hovered days (not scheduled) - now using gray
                Circle()
                        .fill(!hasScheduledItems && !isSelected && hoveredDay == day && isCurrentMonth ? 
                             theme.secondary.opacity(0.1) : Color.clear)
                    
                    // Light gray filled circle for selected date (only if no scheduled items)
                    Circle()
                        .fill(isSelected && !hasScheduledItems ? theme.secondary.opacity(0.1) : Color.clear)
                }
            )
            // Remove the dot overlay
            //.overlay(
            //    Circle()
            //        .fill(hasScheduledItems ? theme.accent : Color.clear)
            //        .frame(width: 2.5, height: 2.5)
            //        .offset(y: 3),
            //    alignment: .bottom
            //)
            }
            .buttonStyle(.plain)
            .position(x: geometry.size.width/2, y: geometry.size.height/2)
        }
        .frame(height: 20)
            .contentShape(Rectangle())
            .onHover(perform: onHover)
            .disabled(!isCurrentMonth)
            .contextMenu {
                if scheduledDocuments.isEmpty {
                    Text("No scheduled sermons")
                        .font(.system(size: 13))
                        .foregroundStyle(theme.secondary)
                } else {
                    ForEach(scheduledDocuments) { schedule in
                        if let doc = documents.first(where: { $0.id == schedule.documentId }) {
                            Button(action: {
                        // Open the document
                        NotificationCenter.default.post(
                            name: NSNotification.Name("OpenDocument"),
                            object: nil,
                            userInfo: ["documentId": doc.id]
                        )
                            }) {
                                Label {
                                    VStack(alignment: .leading) {
                                        Text(doc.title.isEmpty ? "Untitled" : doc.title)
                                        
                                        // Handle presentation dates and regular schedules differently
                                        if let notes = schedule.notes, notes.starts(with: "Presentation") {
                                            let locationPart = notes.contains(" at ") ? notes.components(separatedBy: " at ")[1] : ""
                                            if !locationPart.isEmpty {
                                                Text("at \(locationPart)")
                                                    .font(.system(size: 11))
                                                    .foregroundStyle(theme.secondary)
                                            }
                                        } else {
                                        Text(schedule.serviceType.rawValue)
                                            .font(.system(size: 11))
                                            .foregroundStyle(theme.secondary)
                                        }
                                    }
                                } icon: {
                                    Image(systemName: "doc.text")
                                        .font(.system(size: 10))
                                        .foregroundStyle(theme.primary) // Changed from serviceTypeColor to primary theme color
                                }
                            }
                        }
                    }
                }
            }
    }
    
    private func serviceTypeColor(_ type: ServiceType) -> Color {
        switch type {
        case .sundayMorning:
            return .blue
        case .sundayEvening:
            return .purple
        case .wednesdayNight:
            return .green
        case .special:
            return .orange
        }
    }
}

private struct CalendarGridView: View {
    let days: [Day]
    let selectedDate: Date
    let hoveredDay: Int?
    let documents: [Letterspace_CanvasDocument]
    let calendarDocuments: Set<String>
    let onDaySelect: (Day, CGRect) -> Void
    let onDayHover: (Int?) -> Void
    let hasScheduledItems: (Date) -> Bool
    @Environment(\.themeColors) var theme
    
    var body: some View {
        LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: 0), count: 7), spacing: 0) {
            ForEach(days, id: \.number) { day in
                if let number = day.number {
                    let date = makeDate(from: day)
                    CalendarDayView(
                        day: number,
                        isCurrentMonth: day.isCurrentMonth,
                        isSelected: Calendar.current.isDate(selectedDate, equalTo: date, toGranularity: .day),
                        hasScheduledItems: hasScheduledItems(date),
                        hoveredDay: hoveredDay,
                        documents: documents,
                        calendarDocuments: calendarDocuments,
                        date: date,
                        onSelect: { frame in
                            onDaySelect(day, frame)
                        },
                        onHover: { isHovering in
                            onDayHover(isHovering ? number : nil)
                        }
                    )
                } else {
                    Color.clear
                        .frame(height: 20)  // Updated from 24 to 20 to match CalendarDayView height
                        .frame(maxWidth: .infinity)
                }
            }
        }
    }
    
    private func makeDate(from day: Day) -> Date {
        var dateComponents = DateComponents()
        dateComponents.year = day.year
        dateComponents.month = day.month
        dateComponents.day = day.number
        return Calendar.current.date(from: dateComponents) ?? Date()
    }
}

private struct CalendarSection: View {
    let documents: [Letterspace_CanvasDocument]
    let calendarDocuments: Set<String>
    @Environment(\.themeColors) var theme
    @Environment(\.colorScheme) var colorScheme
    @State private var selectedDate = Date()
    @State private var selectedMonth: Int
    @State private var selectedYear: Int
    @State private var hoveredDay: Int? = nil
    @State private var showListView = false
    @State private var showSchedulePopover = false
    @State private var targetDay: Int? = nil
    @State private var popoverAnchorPoint: CGPoint? = nil
    @State private var showMonthYearPicker = false  // Add state for month/year picker
    @State private var monthPickerAnchorPoint: CGPoint? = nil  // Add anchor point for month/year picker
    @State private var monthYearPopover: NSPopover? = nil
    @State private var monthYearButtonHover = false  // Add hover state for month/year button
    
    init(documents: [Letterspace_CanvasDocument], calendarDocuments: Set<String>) {
        self.documents = documents
        self.calendarDocuments = calendarDocuments
        let calendar = Calendar.current
        let date = Date()
        _selectedYear = State(initialValue: calendar.component(.year, from: date))
        _selectedMonth = State(initialValue: calendar.component(.month, from: date))
    }
    
    private var scheduledDocuments: [ScheduledDocument] {
        let calendar = Calendar.current
        
        // Debug: Print information about all documents with presentation dates
        for doc in documents {
            print("Checking document: \(doc.title)")
            for variation in doc.variations {
                if let presentedDate = variation.datePresented {
                    print("  Has presentation date: \(presentedDate), included in calendar: \(calendarDocuments.contains(doc.id))")
                }
            }
        }
        
        let scheduledFromSchedules = documents.filter { calendarDocuments.contains($0.id) }
            .compactMap { doc -> [ScheduledDocument]? in
                doc.schedules.filter { schedule in
                    schedule.isScheduledFor(date: selectedDate)
                }
            }
            .flatMap { $0 }
            .sorted { $0.startDate < $1.startDate }
        
        // Also check for documents with datePresented matching this date
        // Create virtual ScheduledDocument entries for presentations
        let presentedDocuments = documents // Removed filter for calendarDocuments
            .flatMap { doc -> [ScheduledDocument] in
                doc.variations.compactMap { variation -> ScheduledDocument? in
                    if let presentedDate = variation.datePresented,
                       calendar.isDate(selectedDate, equalTo: presentedDate, toGranularity: .day) {
                        // Create a virtual ScheduledDocument for this presentation
                        return ScheduledDocument(
                            documentId: doc.id,
                            serviceType: .special, // Default to special service type
                            startDate: presentedDate,
                            notes: "Presentation" + (variation.location != nil ? " at \(variation.location!)" : "")
                        )
                    }
                    return nil
                }
            }
        
        // Combine and sort both types of documents
        return (scheduledFromSchedules + presentedDocuments)
            .sorted { $0.startDate < $1.startDate }
    }
    
    var body: some View {
        ZStack(alignment: .topLeading) {
            // Main content
            VStack(alignment: .leading, spacing: 12) {
            HStack(spacing: 8) {
                Image(systemName: "calendar.badge.plus")
                    .font(.system(size: 14))
                    .foregroundStyle(theme.primary)
                Text("Sermon Schedule")
                    .font(.custom("InterTight-Medium", size: 16))
                    .foregroundStyle(theme.primary)
                        
                    Spacer()
                    
                    // View toggle
                    Button(action: {
                        showListView.toggle()
                    }) {
                        Image(systemName: showListView ? "calendar" : "list.bullet")
                            .font(.system(size: 14))
                            .foregroundStyle(theme.secondary)
                    }
                    .buttonStyle(.plain)
                    .help(showListView ? "Show Calendar View" : "Show List View")
            }
            .padding(.leading, 4)
            
            // Add divider
            Rectangle()
                .fill(Color(.separatorColor))
                .frame(height: 1)
                .padding(.vertical, 4)
            
                if showListView {
                    // List View
                    ScheduleListView(
                        documents: documents,
                        calendarDocuments: calendarDocuments,
                        month: selectedMonth,
                        year: selectedYear
                    )
                    .frame(height: 137)
                } else {
            // Calendar View
            VStack(spacing: 3) {  // Further reduced spacing from 4 to 3
                // Month/Year header
                HStack {
                    Button(action: {
                        // Show month/year picker
                        let globalRect = NSApp.currentEvent?.window?.convertToScreen(
                            NSRect(x: 0, y: 0, width: 0, height: 0)
                        )
                        if let point = globalRect?.origin {
                            monthPickerAnchorPoint = CGPoint(x: point.x, y: point.y)
                            withAnimation(.spring(response: 0.25, dampingFraction: 0.7)) {
                                showMonthYearPicker = true
                            }
                        }
                    }) {
                        HStack(spacing: 3) {
                    Text("\(Calendar.current.monthSymbols[selectedMonth - 1]), \(String(selectedYear))")
                                .font(.custom("InterTight-Medium", size: 11))
                                .tracking(0.4)
                        .foregroundStyle(theme.primary)
                            
                            Image(systemName: "chevron.down")
                                .font(.system(size: 9))  // Further reduced from 10 to 9
                                .foregroundStyle(theme.secondary)
                        }
                        .padding(.vertical, 4)
                        .padding(.horizontal, 6)
                        .background(
                            RoundedRectangle(cornerRadius: 4)
                                .fill(theme.primary.opacity(0.05))
                                .opacity(monthYearButtonHover ? 1 : 0)
                        )
                    }
                    .buttonStyle(.plain)
                    .onHover { isHovered in
                        withAnimation(.easeInOut(duration: 0.15)) {
                            monthYearButtonHover = isHovered
                        }
                    }
                    .popover(isPresented: $showMonthYearPicker) {
                        MonthYearPickerView(
                            selectedMonth: $selectedMonth,
                            selectedYear: $selectedYear,
                            onDismiss: { showMonthYearPicker = false }
                        )
                    }
                    
                    Spacer()
                    
                    // Navigation buttons
                    HStack(spacing: 6) {  // Reduced from 8 to 6 to match more compact layout
                        CalendarNavigationButton(icon: "chevron.left", action: previousMonth)
                        
                        CalendarNavigationButton(label: "Today", action: {
                            goToToday()
                            selectedDate = Date() // Also select today's date
                        })
                        
                        CalendarNavigationButton(icon: "chevron.right", action: nextMonth)
                    }
                }
                .padding(.top, 2)  // Reduced from 4 to 2
                
                // Day labels
                HStack(spacing: 0) {
                    ForEach(Calendar.current.veryShortWeekdaySymbols, id: \.self) { day in
                        Text(day)
                            .font(.custom("InterTight-Regular", size: 8))  // Increased from 7 to 8
                            .foregroundStyle(theme.secondary)
                            .frame(maxWidth: .infinity)
                    }
                }
                .padding(.top, 1)  // Reduced from 2 to 1
                
                // Calendar grid with updated onDaySelect
                let days = Calendar.current.daysInMonth(year: selectedYear, month: selectedMonth)
                CalendarGridView(
                    days: days,
                    selectedDate: selectedDate,
                    hoveredDay: hoveredDay,
                    documents: documents,
                    calendarDocuments: calendarDocuments,
                    onDaySelect: { day, frame in
                        if let number = day.number {
                            selectDate(day: number)
                            targetDay = number
                            popoverAnchorPoint = CGPoint(x: frame.midX, y: frame.midY)
                            withAnimation(.spring(response: 0.25, dampingFraction: 0.7)) {
                                showSchedulePopover = true
                            }
                        }
                    },
                    onDayHover: { hoveredDay = $0 },
                    hasScheduledItems: hasScheduledItems(on:)
                )
            }
            .padding(EdgeInsets(top: 16, leading: 10, bottom: 16, trailing: 10))  // Increased vertical padding from 14 to 16
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.clear)
            )
            .frame(height: 137)
        }
            }
            .padding(EdgeInsets(top: 20, leading: 24, bottom: 20, trailing: 24))
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(colorScheme == .dark ? Color(.sRGB, white: 0.12) : .white)
        )
        .clipShape(RoundedRectangle(cornerRadius: 12))
        .shadow(
                color: colorScheme == .dark ? .black.opacity(0.17) : .black.opacity(0.07),
            radius: 8,
            x: 0,
            y: 1
        )
            // Add blur overlay when popup is visible
            .overlay {
                if showSchedulePopover {
                    Rectangle()
                        .fill(colorScheme == .dark ? 
                              Color.black.opacity(0.4) : 
                              Color.white.opacity(0.4))
                        .blur(radius: 8)
                        .ignoresSafeArea()
                        .allowsHitTesting(false)
                        .transition(.opacity)
                        .animation(.easeInOut(duration: 0.2), value: showSchedulePopover)
                }
            }
            .overlay {
                if showSchedulePopover, let anchorPoint = popoverAnchorPoint {
                    // Background tappable area to dismiss the popover
                    Color.clear
                        .contentShape(Rectangle())
                        .onTapGesture {
                            withAnimation(.easeOut(duration: 0.2)) {
                                showSchedulePopover = false
                            }
                        }
                    
                    GeometryReader { geometry in
                        let localX = anchorPoint.x - geometry.frame(in: .global).minX
                        let localY = anchorPoint.y - geometry.frame(in: .global).minY
                        
                        // Calculate popup dimensions
                        let popupWidth: CGFloat = 300
                        let popupHeight: CGFloat = scheduledDocuments.isEmpty ? 100 : min(300, CGFloat(scheduledDocuments.count * 80 + 60))
                        let parentWidth = geometry.size.width
                        let parentHeight = geometry.size.height
                        
                        // Calculate safe positions that prevent clipping
                        let safeX = min(max(popupWidth/2, localX), parentWidth - popupWidth/2)
                        let preferredY = localY - 90
                        
                        // If popup would extend below the bottom edge, position it above the date instead
                        let safeY = preferredY + popupHeight > parentHeight 
                            ? localY - popupHeight - 20 // Position above with padding
                            : preferredY
                        
                        // Two-layer approach: animated container and stable content
                        ZStack {
                            // 1. Card background with animations
                            RoundedRectangle(cornerRadius: 12)
                                .fill(colorScheme == .dark ? Color(.sRGB, white: 0.2) : .white)
                                .shadow(color: .black.opacity(0.25), radius: 12, x: 0, y: 3)
                                .transition(.asymmetric(
                                    insertion: .opacity.combined(with: .scale(scale: 0.9)),
                                    removal: .opacity.combined(with: .scale(scale: 0.95))
                                ))
                                .animation(.spring(response: 0.25, dampingFraction: 0.7, blendDuration: 0), value: showSchedulePopover)
                            
                            // 2. Content without animations
                            SchedulePopoverView(
                                isPresented: $showSchedulePopover,
                                date: selectedDate,
                                documents: documents,
                                scheduledDocuments: scheduledDocuments
                            )
                            // Replace deprecated animation(nil) with modern approach
                            .transaction { transaction in
                                transaction.animation = nil
                            }
                        }
                        .frame(width: popupWidth, height: popupHeight)
                        .position(
                            x: safeX,
                            y: safeY
                        )
                    }
                    .zIndex(1000)
                }
            }
        }
    }
    
    // Update SchedulePopoverView to accept binding for dismiss
    private struct SchedulePopoverView: View {
        @Binding var isPresented: Bool
        let date: Date
        let documents: [Letterspace_CanvasDocument]
        let scheduledDocuments: [ScheduledDocument]
        @Environment(\.themeColors) var theme
        @Environment(\.colorScheme) var colorScheme
        @State private var isCloseButtonHovered = false
        
        var body: some View {
            VStack(alignment: .leading, spacing: 12) {
                // Header
                HStack {
                    Text(formatFullDate(date))
                        .font(.system(size: 14, weight: .semibold))
                        .foregroundStyle(theme.primary)
                    
                    Spacer()
                    
                    Button(action: { 
                        withAnimation(.easeOut(duration: 0.2)) {
                            isPresented = false 
                        }
                    }) {
                        Image(systemName: "xmark")
                            .font(.system(size: 12))
                            .foregroundStyle(isCloseButtonHovered ? theme.primary : theme.secondary)
                            .padding(4)
                            .background(Circle().fill(isCloseButtonHovered ? 
                                (colorScheme == .dark ? Color(.sRGB, white: 0.3) : Color(.sRGB, white: 0.9)) : 
                                Color.clear))
                            .contentShape(Circle())
                    }
                    .buttonStyle(.plain)
                    .onHover { hovering in
                        isCloseButtonHovered = hovering
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 16)
                
                Divider()
                
                if scheduledDocuments.isEmpty {
                    Text("No scheduled items for this date")
                        .font(.system(size: 12))
                        .foregroundStyle(theme.secondary)
                        .frame(maxWidth: .infinity, alignment: .center)
                        .padding(.vertical, 24)
                } else {
                    ScrollView {
                        VStack(alignment: .leading, spacing: 8) {
                            ForEach(Array(scheduledDocuments.enumerated()), id: \.element.id) { index, schedule in
                                if let doc = documents.first(where: { $0.id == schedule.documentId }) {
                                    Button(action: {
                                        // Open the document
                                        NotificationCenter.default.post(
                                            name: NSNotification.Name("OpenDocument"),
                                            object: nil,
                                            userInfo: ["documentId": doc.id]
                                        )
                                        isPresented = false
                                    }) {
                                        HStack(alignment: .center, spacing: 12) {
                                            // Replace circle with document icon
                                            Image(systemName: "doc.text")
                                                .font(.system(size: 12))
                                                .foregroundStyle(theme.primary) // Changed from serviceTypeColor to primary theme color
                                            
                                            VStack(alignment: .leading, spacing: 4) {
                                                Text(doc.title.isEmpty ? "Untitled" : doc.title)
                                                    .font(.system(size: 13, weight: .medium))
                                                    .foregroundStyle(theme.primary)
                                                    .lineLimit(1)
                                                
                                                // Check if this is a presentation date (virtual schedule) or a regular schedule
                                                if let notes = schedule.notes, notes.starts(with: "Presentation") {
                                                    // Show location if available
                                                    let locationPart = notes.contains(" at ") ? notes.components(separatedBy: " at ")[1] : ""
                                                    if !locationPart.isEmpty {
                                                        Text("at \(locationPart)")
                                                            .font(.system(size: 11))
                                                            .foregroundStyle(theme.secondary)
                                                            .lineLimit(1)
                                                    }
                                                } else {
                                                    Text(schedule.serviceType.rawValue)
                                                        .font(.system(size: 11))
                                                        .foregroundStyle(theme.secondary)
                                                    
                                                    if let notes = schedule.notes, !notes.isEmpty {
                                                        Text(notes)
                                                            .font(.system(size: 11))
                                                            .foregroundStyle(theme.secondary)
                                                            .lineLimit(2)
                                                    }
                                                }
                                            }
                                            
                                            Spacer()
                                            
                                            Image(systemName: "chevron.right")
                                                .font(.system(size: 10))
                                                .foregroundStyle(theme.secondary)
                                        }
                                        .padding(.vertical, 8)
                                        .padding(.horizontal, 12)
                                        .background(
                                            RoundedRectangle(cornerRadius: 8)
                                                .fill(Color.clear)
                                        )
                                        .contentShape(Rectangle())
                                    }
                                    .buttonStyle(.plain)
                                    .background(
                                        RoundedRectangle(cornerRadius: 8)
                                            .fill(colorScheme == .dark ? Color(.sRGB, white: 0.25) : Color(.sRGB, white: 0.96))
                                    )
                                    .padding(.horizontal, 16)
                                    // Remove item animations
                                }
                            }
                        }
                        .padding(.vertical, 8)
                    }
                    .padding(.bottom, 8)
                }
            }
        }
        
        private func formatFullDate(_ date: Date) -> String {
            let formatter = DateFormatter()
            formatter.dateStyle = .full
            return formatter.string(from: date)
        }
        
        private func serviceTypeColor(_ type: ServiceType) -> Color {
            switch type {
            case .sundayMorning:
                return .blue
            case .sundayEvening:
                return .purple
            case .wednesdayNight:
                return .green
            case .special:
                return .orange
            }
        }
    }
    
    // New view for the list view of scheduled documents
    private struct ScheduleListView: View {
        let documents: [Letterspace_CanvasDocument]
        let calendarDocuments: Set<String>
        let month: Int
        let year: Int
        @Environment(\.themeColors) var theme
        @Environment(\.colorScheme) var colorScheme
        
        var body: some View {
            ScrollView {
                VStack(alignment: .leading, spacing: 1) {
                    ForEach(daysWithSchedules, id: \.date) { dayInfo in
                        VStack(alignment: .leading, spacing: 0) {
                            // Date header
                            HStack {
                                Text(formatDate(dayInfo.date))
                                    .font(.system(size: 12, weight: .medium))
                                    .foregroundStyle(theme.primary)
                                
                                Spacer()
                                
                                Text(formatWeekday(dayInfo.date))
                                    .font(.system(size: 11))
                                    .foregroundStyle(theme.secondary)
                            }
                            .padding(.horizontal, 12)
                            .padding(.vertical, 6)
                            .background(colorScheme == .dark ? Color(.sRGB, white: 0.22) : Color(.sRGB, white: 0.93))
                            
                            // Scheduled documents
                            ForEach(dayInfo.schedules) { schedule in
                                if let doc = documents.first(where: { $0.id == schedule.documentId }) {
                                    Button(action: {
                                        // Open the document
                                        NotificationCenter.default.post(
                                            name: NSNotification.Name("OpenDocument"),
                                            object: nil,
                                            userInfo: ["documentId": doc.id]
                                        )
                                    }) {
                                        HStack(spacing: 10) {
                                            Image(systemName: "doc.text")
                                                .font(.system(size: 10))
                                                .foregroundStyle(serviceTypeColor(schedule.serviceType))
                                            
                                            Text(doc.title.isEmpty ? "Untitled" : doc.title)
                                                .font(.system(size: 12))
                                                .foregroundStyle(theme.primary)
                                                .lineLimit(1)
                                            
                                            Spacer()
                                            
                                            Text(schedule.serviceType.rawValue)
                                                .font(.system(size: 11))
                                                .foregroundStyle(theme.secondary)
                                        }
                                        .padding(.horizontal, 12)
                                        .padding(.vertical, 6)
                                        .contentShape(Rectangle())
                                    }
                                    .buttonStyle(.plain)
                                    .background(colorScheme == .dark ? Color(.sRGB, white: 0.15) : .white)
                                }
                            }
                        }
                        .background(colorScheme == .dark ? Color(.sRGB, white: 0.15) : .white)
                        .cornerRadius(6)
                        .padding(.bottom, 4)
                    }
                    
                    // Show when no documents
                    if daysWithSchedules.isEmpty {
                        Text("No scheduled items this month")
                            .font(.system(size: 12))
                            .foregroundStyle(theme.secondary)
                            .frame(maxWidth: .infinity, alignment: .center)
                            .padding()
                    }
                }
                .padding(.vertical, 8)
            }
        }
        
        // Get all days in the month that have schedules
        private var daysWithSchedules: [DayInfo] {
            print("Checking for scheduled days in month \(month)")
            // Get all days in month
            let days = (1...daysInMonth()).compactMap { day -> DayInfo? in
                let date = makeDate(day: day)
                let schedules = getSchedulesForDate(date)
                print("Day \(day): found \(schedules.count) schedules")
                if !schedules.isEmpty {
                    return DayInfo(date: date, schedules: schedules)
                }
                return nil
            }
            return days.sorted(by: { $0.date < $1.date })
        }
        
        // Generate schedules for a specific date
        private func getSchedulesForDate(_ date: Date) -> [ScheduledDocument] {
            let calendar = Calendar.current
            
            // Get documents from explicit schedules
            let scheduledFromSchedules = documents.filter { calendarDocuments.contains($0.id) }
                .compactMap { doc -> [ScheduledDocument]? in
                    doc.schedules.filter { schedule in
                        schedule.isScheduledFor(date: date)
                    }
                }
                .flatMap { $0 }
            
            // Also check for documents with datePresented matching this date
            let presentedDocuments = documents
                .flatMap { doc -> [ScheduledDocument] in
                    doc.variations.compactMap { variation -> ScheduledDocument? in
                        if let presentedDate = variation.datePresented,
                           calendar.isDate(date, equalTo: presentedDate, toGranularity: .day) {
                            // Create a virtual ScheduledDocument for this presentation
                            return ScheduledDocument(
                                documentId: doc.id,
                                serviceType: .special, // Default to special service type
                                startDate: presentedDate,
                                notes: "Presentation" + (variation.location != nil ? " at \(variation.location!)" : "")
                            )
                        }
                        return nil
                    }
                }
            
            // Combine both types of documents and sort by date
            return (scheduledFromSchedules + presentedDocuments)
                .sorted { $0.startDate < $1.startDate }
        }
        
        private func daysInMonth() -> Int {
            let calendar = Calendar.current
            if let range = calendar.range(of: .day, in: .month, for: makeDate(day: 1)) {
                return range.count
            }
            return 30
    }
    
    private func makeDate(day: Int) -> Date {
            return Calendar.current.date(from: DateComponents(year: year, month: month, day: day)) ?? Date()
        }
        
        private func formatDate(_ date: Date) -> String {
            let formatter = DateFormatter()
            formatter.dateFormat = "MMMM d"
            return formatter.string(from: date)
        }
        
        private func formatWeekday(_ date: Date) -> String {
            let formatter = DateFormatter()
            formatter.dateFormat = "EEEE"
            return formatter.string(from: date)
        }
        
        private func serviceTypeColor(_ type: ServiceType) -> Color {
            switch type {
            case .sundayMorning:
                return .blue
            case .sundayEvening:
                return .purple
            case .wednesdayNight:
                return .green
            case .special:
                return .orange
            }
        }
        
        // Helper struct to group schedules by date
        struct DayInfo {
            let date: Date
            let schedules: [ScheduledDocument]
        }
    }
    
    private func makeDate(day: Int) -> Date {
        return Calendar.current.date(from: DateComponents(year: selectedYear, month: selectedMonth, day: day)) ?? Date()
    }
    
    private func selectDate(day: Int) {
        selectedDate = makeDate(day: day)
    }
    
    private func goToToday() {
        let today = Date()
        let calendar = Calendar.current
        selectedMonth = calendar.component(.month, from: today)
        selectedYear = calendar.component(.year, from: today)
        selectedDate = today // Also select today's date
    }
    
    private func previousMonth() {
        if selectedMonth == 1 {
            selectedMonth = 12
            selectedYear -= 1
        } else {
            selectedMonth -= 1
        }
    }
    
    private func nextMonth() {
        if selectedMonth == 12 {
            selectedMonth = 1
            selectedYear += 1
        } else {
            selectedMonth += 1
        }
    }
    
    private func hasScheduledItems(on date: Date) -> Bool {
        let calendar = Calendar.current
        
        // Check if any document is scheduled for this date via the schedules collection
        for document in documents where calendarDocuments.contains(document.id) {
            for schedule in document.schedules {
                if schedule.isScheduledFor(date: date) {
                    return true
                }
            }
            
            // Also check if any variation of this document has a datePresented matching this date
            for variation in document.variations {
                if let presentedDate = variation.datePresented, 
                   calendar.isDate(date, equalTo: presentedDate, toGranularity: .day) {
                    return true
                }
            }
        }
        
        // Check if any document has a datePresented matching this date (even if not in calendarDocuments)
        for document in documents {
            for variation in document.variations {
                if let presentedDate = variation.datePresented, 
                   calendar.isDate(date, equalTo: presentedDate, toGranularity: .day) {
                    return true
                }
            }
        }
        
        return false
    }
}

struct SchedulePopup: View {
    let date: Date
    let documents: [Letterspace_CanvasDocument]
    let scheduledDocuments: [ScheduledDocument]
    let anchorPoint: CGPoint
    @Binding var isShowing: Bool
    @Environment(\.themeColors) var theme
    @Environment(\.colorScheme) var colorScheme
    @State private var opacity = 0.0
    @State private var scale = 0.8
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Header
            Text(formatDate(date))
                .font(.system(size: 13, weight: .medium))
                .foregroundStyle(theme.primary)
            
            // Scheduled documents list
            VStack(alignment: .leading, spacing: 8) {
                if scheduledDocuments.isEmpty {
                    Text("No scheduled documents")
                        .font(.system(size: 13))
                        .foregroundStyle(theme.secondary)
                } else {
                    ForEach(scheduledDocuments) { schedule in
                        if let doc = documents.first(where: { $0.id == schedule.documentId }) {
                            HStack(spacing: 12) {
                                // Service type indicator
                                Circle()
                                    .fill(serviceTypeColor(schedule.serviceType))
                                    .frame(width: 8, height: 8)
                                
                                VStack(alignment: .leading, spacing: 2) {
                                    Text(doc.title.isEmpty ? "Untitled" : doc.title)
                                        .font(.system(size: 13, weight: .medium))
                                        .foregroundStyle(theme.primary)
                                    
                                    Text(schedule.serviceType.rawValue)
                                        .font(.system(size: 12))
                                        .foregroundStyle(theme.secondary)
                                }
                            }
                            .padding(.vertical, 6)
                            .padding(.horizontal, 8)
                            .background(
                                RoundedRectangle(cornerRadius: 6)
                                    .fill(colorScheme == .dark ? Color(.sRGB, white: 0.2) : .white)
                            )
                        }
                    }
                }
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(colorScheme == .dark ? Color(.sRGB, white: 0.12) : .white)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(Color.gray.opacity(0.1), lineWidth: 1)
        )
        .shadow(color: .black.opacity(0.15), radius: 15, x: 0, y: 2)
        .position(x: anchorPoint.x, y: anchorPoint.y)
        .opacity(opacity)
        .scaleEffect(scale)
        .onAppear {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                opacity = 1.0
                scale = 1.0
            }
        }
        .onTapGesture {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                opacity = 0.0
                scale = 0.8
                isShowing = false
            }
        }
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "EEEE, MMMM d"
        return formatter.string(from: date)
    }
    
    private func serviceTypeColor(_ type: ServiceType) -> Color {
        switch type {
        case .sundayMorning:
            return .blue
        case .sundayEvening:
            return .purple
        case .wednesdayNight:
            return .green
        case .special:
            return .orange
        }
    }
}

private struct CalendarNavigationButton: View {
    let icon: String?
    let label: String?
    let action: () -> Void
    @State private var isHovering = false
    @Environment(\.themeColors) var theme
    
    init(icon: String? = nil, label: String? = nil, action: @escaping () -> Void) {
        self.icon = icon
        self.label = label
        self.action = action
    }
    
    var body: some View {
        Button(action: action) {
            Group {
                if let icon = icon {
                    Image(systemName: icon)
                        .font(.system(size: 10, weight: .medium))  // Reduced from 12 to 10
                } else if let label = label {
                    Text(label)
                        .font(.custom("InterTight-Medium", size: 11))  // Changed from Regular to Medium
                        .kerning(label == "Today" ? 0.3 : 0.0)  // Reduced kerning from 0.4 to 0.3
                }
            }
            .foregroundStyle(theme.primary)
            .padding(.horizontal, 5)  // Reduced from 6 to 5
            .padding(.vertical, 3)  // Reduced from 4 to 3
            .background(
                RoundedRectangle(cornerRadius: 3)  // Reduced from 4 to 3
                    .fill(theme.primary.opacity(isHovering ? 0.1 : 0))
            )
        }
        .buttonStyle(.plain)
        .onHover { hovering in
            withAnimation(.easeOut(duration: 0.15)) {
                isHovering = hovering
            }
        }
    }
}

private struct ScheduleSheet: View {
    let document: Letterspace_CanvasDocument
    @Binding var isPresented: Bool
    @Environment(\.themeColors) var theme
    @Environment(\.colorScheme) var colorScheme
    
    @State private var selectedDate = Date()
    @State private var selectedServiceType: ServiceType = .sundayMorning
    @State private var selectedRecurrenceType = "once"
    @State private var selectedDaysOfWeek: Set<Int> = []
    @State private var selectedDayOfMonth = 1
    @State private var selectedMonth = 1
    @State private var selectedDayOfYear = 1
    @State private var notes: String = ""
    
    private var recurrencePattern: RecurrencePattern {
        switch selectedRecurrenceType {
        case "once":
            return .once
        case "weekly":
            return .weekly(daysOfWeek: selectedDaysOfWeek)
        case "monthly":
            return .monthly(dayOfMonth: selectedDayOfMonth)
        case "yearly":
            return .yearly(month: selectedMonth, day: selectedDayOfYear)
        default:
            return .once
        }
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 24) {
            // Header
            HStack {
                Text("Schedule Sermon")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundStyle(theme.primary)
                
                Spacer()
                
                Button(action: { isPresented = false }) {
                    Image(systemName: "xmark")
                        .font(.system(size: 12))
                        .foregroundStyle(theme.secondary)
                }
                .buttonStyle(.plain)
            }
            
            // Document Title
            VStack(alignment: .leading, spacing: 8) {
                Text("Document")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundStyle(theme.secondary)
                
                Text(document.title.isEmpty ? "Untitled" : document.title)
                    .font(.system(size: 13))
                    .foregroundStyle(theme.primary)
                    .padding(8)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .background(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97))
                    .cornerRadius(6)
            }
            
            // Date Selection
            VStack(alignment: .leading, spacing: 8) {
                Text("Date")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundStyle(theme.secondary)
                
                DatePicker("", selection: $selectedDate, displayedComponents: [.date])
                    .datePickerStyle(.graphical)
                    .labelsHidden()
            }
            
            // Service Type
            VStack(alignment: .leading, spacing: 8) {
                Text("Service Type")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundStyle(theme.secondary)
                
                Picker("Service Type", selection: $selectedServiceType) {
                    ForEach(ServiceType.allCases, id: \.self) { type in
                        Text(type.rawValue)
                            .tag(type)
                    }
                }
                .pickerStyle(.menu)
            }
            
            // Recurrence
            VStack(alignment: .leading, spacing: 8) {
                Text("Recurrence")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundStyle(theme.secondary)
                
                Picker("Recurrence", selection: $selectedRecurrenceType) {
                    Text("Once").tag("once")
                    Text("Weekly").tag("weekly")
                    Text("Monthly").tag("monthly")
                    Text("Yearly").tag("yearly")
                }
                .pickerStyle(.menu)
                
                
                // Additional options based on recurrence type
                if selectedRecurrenceType == "weekly" {
                    HStack {
                        ForEach(1...7, id: \.self) { day in
                            let dayName = Calendar.current.shortWeekdaySymbols[day - 1]
                            Toggle(dayName, isOn: Binding(
                                get: { selectedDaysOfWeek.contains(day) },
                                set: { isSelected in
                                    if isSelected {
                                        selectedDaysOfWeek.insert(day)
                                    } else {
                                        selectedDaysOfWeek.remove(day)
                                    }
                                }
                            ))
                            .toggleStyle(.button)
                            .buttonStyle(.bordered)
                        }
                    }
                } else if selectedRecurrenceType == "monthly" {
                    Picker("Day of Month", selection: $selectedDayOfMonth) {
                        ForEach(1...31, id: \.self) { day in
                            Text("\(day)").tag(day)
                        }
                    }
                    .pickerStyle(.menu)
                } else if selectedRecurrenceType == "yearly" {
                    HStack {
                        Picker("Month", selection: $selectedMonth) {
                            ForEach(1...12, id: \.self) { month in
                                Text(Calendar.current.monthSymbols[month - 1]).tag(month)
                            }
                        }
                        .pickerStyle(.menu)
                        
                        Picker("Day", selection: $selectedDayOfYear) {
                            ForEach(1...31, id: \.self) { day in
                                Text("\(day)").tag(day)
                            }
                        }
                        .pickerStyle(.menu)
                    }
                }
            }
            
            // Notes
            VStack(alignment: .leading, spacing: 8) {
                Text("Notes")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundStyle(theme.secondary)
                
                
                TextEditor(text: $notes)
                    .font(.system(size: 13))
                    .frame(height: 80)
                    .padding(8)
                    .background(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97))
                    .cornerRadius(6)
            }
            
            Spacer()
            
            // Action Buttons
            HStack {
                Spacer()
                
                Button(action: { isPresented = false }) {
                    Text("Cancel")
                        .font(.system(size: 13))
                        .foregroundStyle(theme.secondary)
                }
                .buttonStyle(.plain)
                .keyboardShortcut(.escape, modifiers: [])
                
                Button(action: scheduleDocument) {
                    Text("Schedule")
                        .font(.system(size: 13, weight: .medium))
                        .foregroundStyle(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 6)
                        .background(theme.accent)
                        .cornerRadius(6)
                }
                .keyboardShortcut(.return, modifiers: [.command])
            }
        }
        .padding(24)
        .frame(width: 400)
        .background(colorScheme == .dark ? Color(.sRGB, white: 0.12) : .white)
        .clipShape(RoundedRectangle(cornerRadius: 12))
    }
    
    private func scheduleDocument() {
        var updatedDoc = document
        let schedule = ScheduledDocument(
            documentId: document.id,
            serviceType: selectedServiceType,
            startDate: selectedDate,
            endDate: nil,
            recurrence: recurrencePattern,
            notes: notes.isEmpty ? nil : notes
        )
        updatedDoc.addSchedule(schedule)
        isPresented = false
        
        // Notify that document list should update
        NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
    }
}

// Add placeholder modifier at file scope
extension View {
    func placeholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .leading,
        @ViewBuilder placeholder: () -> Content) -> some View {
        
        
        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}

struct CalendarContextMenu: View {
    let document: Letterspace_CanvasDocument
    @Binding var showScheduleSheet: Bool
    let onCalendar: (String) -> Void
    @State private var scheduledDate: Date = Date()
    @State private var serviceTime: String = ""
    @State private var notes: String = ""
    @Environment(\.themeColors) var theme
    
    var body: some View {
        ZStack {
            // Semi-transparent overlay to block interactions
            if showScheduleSheet {
                Color.clear
                    .contentShape(Rectangle())
                    .onTapGesture {
                        showScheduleSheet = false
                    }
                    .ignoresSafeArea()
            }
            
            // Menu content
            VStack(spacing: 12) {
                Text("Schedule Document")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundStyle(theme.primary)
                    .padding(.bottom, 4)
                
                // Scheduled Date
                VStack(alignment: .leading, spacing: 4) {
                    Text("Date")
                        .font(.system(size: 12))
                        .foregroundStyle(theme.secondary)
                    DatePicker("Scheduled Date", selection: $scheduledDate, displayedComponents: [.date])
                        .datePickerStyle(.compact)
                        .labelsHidden()
                }
                
                // Service Time
                VStack(alignment: .leading, spacing: 4) {
                    Text("Service Time")
                        .font(.system(size: 12))
                        .foregroundStyle(theme.secondary)
                    TextField("e.g. 9:00 AM", text: $serviceTime)
                        .textFieldStyle(.roundedBorder)
                        .font(.system(size: 12))
                }
                
                // Notes
                VStack(alignment: .leading, spacing: 4) {
                    Text("Notes")
                        .font(.system(size: 12))
                        .foregroundStyle(theme.secondary)
                    TextField("Add notes...", text: $notes)
                        .textFieldStyle(.roundedBorder)
                        .font(.system(size: 12))
                }
                
                // Schedule Button
                Button(action: {
                    // Save the scheduled date and details
                    var updatedDoc = document
                    if var firstVariation = updatedDoc.variations.first {
                        firstVariation.datePresented = scheduledDate
                        firstVariation.serviceTime = serviceTime
                        firstVariation.notes = notes
                        updatedDoc.variations[0] = firstVariation
                    } else {
                        let variation = DocumentVariation(
                            id: UUID(),
                            name: "Original",
                            documentId: document.id,
                            parentDocumentId: document.id,
                            createdAt: Date(),
                            datePresented: scheduledDate,
                            location: nil,
                            serviceTime: serviceTime,
                            notes: notes
                        )
                        updatedDoc.variations = [variation]
                    }
                    
                    // Save the document
                    updatedDoc.save()
                    
                    // Mark as scheduled in calendar
                    onCalendar(document.id)
                    
                    // Post notification to update the document list
                    NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
                    
                    // Close the menu
                    showScheduleSheet = false
                }) {
                    Text("Schedule")
                        .font(.system(size: 12, weight: .medium))
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 6)
                        .background(Color.blue)
                        .cornerRadius(6)
                }
                .buttonStyle(.plain)
            }
            .padding(12)
            .frame(width: 240)
            .background(theme.background)
            .cornerRadius(8)
            .shadow(color: .black.opacity(0.2), radius: 8, x: 0, y: 2)
        }
        .allowsHitTesting(true)
    }
}

// Add this extension at the bottom of the file
private extension NSView {
    var descendantViews: [NSView] {
        var views = [NSView]()
        for subview in subviews {
            views.append(subview)
            views.append(contentsOf: subview.descendantViews)
        }
        return views
    }
}

// Custom button style for hover effect with accent color
struct HoverButtonStyle: ButtonStyle {
    @Environment(\.colorScheme) var colorScheme
    @State private var isHovering = false
    
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color(hex: "#22c27d").opacity(isHovering ? 0.15 : 0))
            )
            .onHover { hovering in
                withAnimation(.easeInOut(duration: 0.15)) {
                    isHovering = hovering
                }
            }
            .scaleEffect(configuration.isPressed ? 0.98 : 1.0)
    }
}

// HoverButton for variation items
struct HoverButton: View {
    let title: String
    let label: String
    let subtitle: String?
    let date: Date?
    let onHover: (Bool) -> Void
    @State private var isHovering = false
    
    init(title: String, label: String, subtitle: String? = nil, date: Date? = nil, onHover: @escaping (Bool) -> Void) {
        self.title = title
        self.label = label
        self.subtitle = subtitle
        self.date = date
        self.onHover = onHover
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .none
        return formatter.string(from: date)
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(title)
                    .font(DesignSystem.Typography.medium(size: 12))
                    .foregroundStyle(Color.black)
                    .lineLimit(1)
                
                Spacer()
                
                Text(label)
                    .font(DesignSystem.Typography.regular(size: 10))
                    .foregroundStyle(Color(.secondaryLabelColor))
            }
            
            if subtitle != nil || date != nil {
                HStack {
                    if let subtitle = subtitle, !subtitle.isEmpty {
                        Text(subtitle)
                            .font(DesignSystem.Typography.regular(size: 10))
                            .foregroundStyle(Color(.secondaryLabelColor))
                            .lineLimit(1)
                    }
                    
                    Spacer()
                    
                    if let date = date {
                        Text(formatDate(date))
                            .font(DesignSystem.Typography.regular(size: 10))
                            .foregroundStyle(Color(.secondaryLabelColor))
                    }
                }
            }
        }
        .padding(.vertical, 8)
        .padding(.horizontal, 12)
        .background(
            ZStack {
                RoundedRectangle(cornerRadius: 6)
                    .fill(Color(hex: "#22c27d").opacity(0.1))
                    .opacity(isHovering ? 1 : 0)
                
                RoundedRectangle(cornerRadius: 6)
                    .stroke(Color.black, lineWidth: 1)
            }
        )
        .contentShape(Rectangle())
        .onHover { hovering in
            withAnimation(.easeInOut(duration: 0.2)) {
                isHovering = hovering
                onHover(hovering)
            }
        }
    }
}

// LinkItemView for displaying links in the DocumentDetailsCard
private struct LinkItemView: View {
    let link: DocumentLink
    @Environment(\.themeColors) var theme
    @Environment(\.colorScheme) var colorScheme
    @State private var isHovering = false
    
    var body: some View {
        Button(action: {
            if let url = URL(string: link.url) {
                NSWorkspace.shared.open(url)
            }
        }) {
            HStack(spacing: 8) {
                Text(link.title)
                    .font(DesignSystem.Typography.medium(size: 12))
                    .foregroundStyle(Color.black)
                    .lineLimit(1)
                
                Spacer()
                
                Text(link.url)
                    .font(DesignSystem.Typography.regular(size: 10))
                    .foregroundStyle(Color(.secondaryLabelColor))
                    .lineLimit(1)
                    .truncationMode(.middle)
            }
            .padding(.vertical, 8)
            .padding(.horizontal, 12)
            .background(
                ZStack {
                    RoundedRectangle(cornerRadius: 6)
                        .fill(Color(hex: "#22c27d").opacity(0.1))
                        .opacity(isHovering ? 1 : 0)
                    
                    RoundedRectangle(cornerRadius: 6)
                        .stroke(Color.black, lineWidth: 1)
                }
            )
            .contentShape(Rectangle())
            .onHover { hovering in
                withAnimation(.easeInOut(duration: 0.2)) {
                    isHovering = hovering
                    if hovering {
                        NSCursor.pointingHand.push()
                    } else {
                        if NSCursor.current == NSCursor.pointingHand {
                            NSCursor.pop()
                        }
                    }
                }
            }
        }
        .buttonStyle(.plain)
    }
}

// CustomShareSheet for the DocumentDetailsCard
struct CustomShareSheet: View {
    let document: Letterspace_CanvasDocument
    @Binding var isPresented: Bool
    @Environment(\.colorScheme) var colorScheme
    @Environment(\.themeColors) var theme
    @State private var showingPrintDialog = false
    @State private var exportProgress: Double?
    @State private var exportError: String?
    
    // PDF export options
    @State private var showHeaderImage = true
    @State private var showDocumentTitle = true
    @State private var showPageNumbers = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header
            HStack {
                Text("Export PDF")
                    .font(.system(size: 14, weight: .semibold))
                    .foregroundStyle(theme.primary)
                
                Spacer()
                
                // Close button
                Button(action: { isPresented = false }) {
                    Image(systemName: "xmark")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundStyle(theme.primary)
                }
                .buttonStyle(.plain)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            
            Divider()
            
            HStack(alignment: .top, spacing: 0) {
                // Left side - Options
                VStack(alignment: .leading, spacing: 16) {
                    // Toggle options with fixed-width container for toggles
                    VStack(alignment: .leading, spacing: 12) {
                        // Document Title Toggle
                        HStack {
                            Text("Hide Document Title")
                                .font(.system(size: 13))
                            
                            Spacer()
                            
                            // Fixed-width container for toggle
                            ZStack(alignment: .trailing) {
                                Rectangle()
                                    .fill(Color.clear)
                                    .frame(width: 50, height: 22)
                                
                                Toggle("", isOn: Binding(
                                    get: { !showDocumentTitle },
                                    set: { showDocumentTitle = !$0 }
                                ))
                                .toggleStyle(.switch)
                                .labelsHidden()
                            }
                        }
                        
                        // Header Image Toggle
                        HStack {
                            Text("Hide Header Image")
                                .font(.system(size: 13))
                            
                            Spacer()
                            
                            // Fixed-width container for toggle
                            ZStack(alignment: .trailing) {
                                Rectangle()
                                    .fill(Color.clear)
                                    .frame(width: 50, height: 22)
                                
                                Toggle("", isOn: Binding(
                                    get: { !showHeaderImage },
                                    set: { showHeaderImage = !$0 }
                                ))
                                .toggleStyle(.switch)
                                .labelsHidden()
                            }
                        }
                        
                        // Page Numbers Toggle
                        HStack {
                            Text("Show Page Numbers")
                                .font(.system(size: 13))
                            
                            Spacer()
                            
                            // Fixed-width container for toggle
                            ZStack(alignment: .trailing) {
                                Rectangle()
                                    .fill(Color.clear)
                                    .frame(width: 50, height: 22)
                                
                                Toggle("", isOn: $showPageNumbers)
                                    .toggleStyle(.switch)
                                    .labelsHidden()
                            }
                        }
                    }
                    
                    Spacer()
                    
                    // Action buttons
                    VStack(spacing: 8) {
                        Button(action: exportAsPDF) {
                            HStack {
                                Spacer()
                                if let progress = exportProgress {
                                    ProgressView(value: progress, total: 1.0)
                                        .progressViewStyle(CircularProgressViewStyle())
                                        .scaleEffect(0.7)
                                        .padding(.trailing, 8)
                                }
                                Text("Save As...")
                                    .font(.system(size: 13, weight: .medium))
                                Spacer()
                            }
                            .padding(.vertical, 8)
                            .background(Color.blue)
                            .foregroundStyle(Color.white)
                            .cornerRadius(6)
                        }
                        .buttonStyle(.plain)
                        
                        Button(action: {
                            showingPrintDialog = true
                            isPresented = false
                        }) {
                            HStack {
                                Spacer()
                                Image(systemName: "printer")
                                    .font(.system(size: 13))
                                    .padding(.trailing, 4)
                                Text("Print")
                                    .font(.system(size: 13, weight: .medium))
                                Spacer()
                            }
                            .padding(.vertical, 8)
                            .background(colorScheme == .dark ? Color(.sRGB, white: 0.3) : Color(.sRGB, white: 0.9))
                            .foregroundStyle(theme.primary)
                            .cornerRadius(6)
                        }
                        .buttonStyle(.plain)
                    }
                    
                    if let error = exportError {
                        Text(error)
                            .font(.system(size: 12))
                            .foregroundStyle(Color.red)
                            .padding(.top, 8)
                    }
                }
                .padding(16)
                .frame(width: 220)
                
                Divider()
                
                // Right side - Document Preview
                ScrollView {
                    VStack(spacing: 0) {
                        // Document preview
                        SimplifiedDocumentPreview(
                            document: document,
                            showHeaderImage: showHeaderImage,
                            showDocumentTitle: showDocumentTitle,
                            showPageNumbers: showPageNumbers
                        )
                        .frame(maxWidth: .infinity)
                    }
                    .frame(maxWidth: .infinity)
                }
                .frame(width: 450, height: 500)
            }
            .frame(width: 670, height: 500)
        }
        .background(colorScheme == .dark ? Color(.sRGB, white: 0.12) : Color(.sRGB, white: 0.97))
        .cornerRadius(10)
        .shadow(color: Color.black.opacity(0.2), radius: 10, x: 0, y: 5)
        .onChange(of: showingPrintDialog) { _, newValue in
            if newValue {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    printDocument()
                }
            }
        }
    }
    
    private func exportAsPDF() {
        // Start progress indicator
        exportProgress = 0.1
        exportError = nil
        
        // Create a save panel
        let savePanel = NSSavePanel()
        savePanel.allowedContentTypes = [UTType.pdf]
        savePanel.canCreateDirectories = true
        savePanel.isExtensionHidden = false
        savePanel.title = "Save PDF"
        savePanel.message = "Choose a location to save the PDF"
        savePanel.nameFieldStringValue = "\(document.title).pdf"
        
        // Show the save panel
        savePanel.begin { response in
            if response == .OK, let url = savePanel.url {
                // Update progress
                exportProgress = 0.3
                
                // Generate PDF data
                DispatchQueue.global(qos: .userInitiated).async {
                    do {
                        // Create PDF data with the selected options
                        let pdfData = generatePDF(
                            document: document,
                            showHeaderImage: showHeaderImage,
                            showDocumentTitle: showDocumentTitle,
                            showPageNumbers: showPageNumbers
                        )
                        
                        // Update progress
                        DispatchQueue.main.async {
                            exportProgress = 0.7
                        }
                        
                        // Write to file
                        try pdfData.write(to: url)
                        
                        // Complete
                        DispatchQueue.main.async {
                            exportProgress = 1.0
                            
                            // Reset after a delay
                            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                                exportProgress = nil
                                isPresented = false
                            }
                        }
                    } catch {
                        DispatchQueue.main.async {
                            exportProgress = nil
                            exportError = "Error exporting PDF: \(error.localizedDescription)"
                        }
                    }
                }
            } else {
                // User cancelled
                DispatchQueue.main.async {
                    exportProgress = nil
                }
            }
        }
    }
    
    // Generate PDF from document
    private func generatePDF(document: Letterspace_CanvasDocument, showHeaderImage: Bool, showDocumentTitle: Bool, showPageNumbers: Bool) -> Data {
        // Use our shared PDFDocumentGenerator utility
        if let pdfData = PDFDocumentGenerator.generatePDFData(
            for: document,
            showHeaderImage: showHeaderImage,
            showDocumentTitle: showDocumentTitle,
            showPageNumbers: showPageNumbers
        ) {
            return pdfData
        }
        
        // Return empty data if generation failed
        return Data()
    }
    
    private func printDocument() {
        // Reset the flag
        showingPrintDialog = false
        
        // Create a print info
        let printInfo = NSPrintInfo.shared
        printInfo.topMargin = 72.0
        printInfo.leftMargin = 72.0
        printInfo.rightMargin = 72.0
        printInfo.bottomMargin = 72.0
        
        // Create a print operation
        let printOperation = NSPrintOperation(view: NSHostingView(rootView: DocumentPrintView(
            document: document,
            showHeaderImage: showHeaderImage,
            showDocumentTitle: showDocumentTitle,
            showPageNumbers: showPageNumbers
        )), printInfo: printInfo)
        printOperation.showsPrintPanel = true
        printOperation.showsProgressPanel = true
        
        // Run the print operation
        printOperation.run()
    }
    
    // Helper function to load header image
    private func loadHeaderImage(from fileName: String) -> NSImage? {
        guard !fileName.isEmpty else { return nil }
        
        // Try to load from document directory first
        let fileManager = FileManager.default
        let documentsDirectory = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first!
        let fileURL = documentsDirectory.appendingPathComponent(fileName)
        
        if fileManager.fileExists(atPath: fileURL.path),
           let image = NSImage(contentsOf: fileURL) {
            return image
        }
        
        // Try to load from bundle as fallback
        return NSImage(named: fileName)
    }
}

// DocumentPrintView for printing functionality
struct DocumentPrintView: View {
    let document: Letterspace_CanvasDocument
    let showHeaderImage: Bool
    let showDocumentTitle: Bool
    let showPageNumbers: Bool
    
    var body: some View {
        VStack(spacing: 0) {
            // Header image
            if showHeaderImage, 
               let _ = document.elements.first(where: { $0.type == .headerImage && !$0.content.isEmpty }) {
                // Simple placeholder for header image
                Text("Header Image")
                    .font(.system(size: 24, weight: .bold))
                    .frame(height: 100)
                    .frame(maxWidth: .infinity)
                    .background(Color.gray.opacity(0.2))
                    .padding(.bottom, 20)
            }
            
            // Document title
            if showDocumentTitle {
                Text(document.title)
                    .font(.system(size: 24, weight: .bold))
                    .padding(.bottom, 16)
            }
            
            // Document content
            VStack(alignment: .leading, spacing: 12) {
                // Filter for text elements
                let textElements = document.elements.filter { 
                    $0.type == .textBlock || $0.type == .header || $0.type == .title || $0.type == .subheader
                }
                
                // Content elements
                ForEach(textElements) { element in
                    switch element.type {
                    case .title:
                        Text(element.content)
                            .font(.system(size: 20, weight: .bold))
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .padding(.vertical, 4)
                    case .header:
                        Text(element.content)
                            .font(.system(size: 18, weight: .bold))
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .padding(.vertical, 4)
                    case .subheader:
                        Text(element.content)
                            .font(.system(size: 16, weight: .semibold))
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .padding(.vertical, 4)
                    case .textBlock:
                        Text(element.content)
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .padding(.vertical, 4)
                    default:
                        EmptyView()
                    }
                }
                
                // Page number
                if showPageNumbers {
                    HStack {
                        Spacer()
                        Text("Page 1")
                            .font(.system(size: 10))
                            .foregroundStyle(Color.gray)
                    }
                    .padding(.top, 20)
                }
            }
            .padding(.bottom, 40)
        }
        .padding(40)
    }
}

struct HeaderImageThumbnail: View {
    let imagePath: String
    let documentId: String
    @Environment(\.themeColors) var theme
    @Environment(\.colorScheme) var colorScheme
    @State private var image: NSImage?
    @State private var isHovering = false
    @State private var showImageMenu = false
    @Binding var document: Letterspace_CanvasDocument
    
    var body: some View {
        Group {
            if let image = image {
                ZStack(alignment: .topTrailing) {
                    Image(nsImage: image)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(maxWidth: .infinity)
                        .clipped()
                        .overlay(
                            Rectangle()
                                .fill(
                                    LinearGradient(
                                        gradient: Gradient(colors: [
                                            colorScheme == .dark 
                                                ? Color.black.opacity(0.5) 
                                                : Color.white.opacity(0.1),
                                            Color.clear
                                        ]),
                                        startPoint: .top,
                                        endPoint: .center
                                    )
                                )
                        )
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .stroke(colorScheme == .dark ? Color.white.opacity(0.1) : Color.black.opacity(0.05), lineWidth: 1)
                        )
                        .onHover { hovering in
                            // Add small delay before hiding to improve usability
                            if !hovering {
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                                    // Only hide if still not hovering after delay
                                    if !isHovering {
                                        isHovering = hovering
                                    }
                                }
                            } else {
                                isHovering = hovering
                            }
                        }
                    
                    // Image management menu
                    if isHovering {
                        Menu {
                            Button(action: {
                                replaceImage()
                            }) {
                                Label("Replace Image", systemImage: "photo")
                            }
                            
                            Button(action: {
                                downloadImage()
                            }) {
                                Label("Download Image", systemImage: "square.and.arrow.down")
                            }
                            
                            Divider()
                            
                            Button(role: .destructive, action: {
                                deleteImage()
                            }) {
                                Label("Delete Image", systemImage: "trash")
                            }
                        } label: {
                            ZStack {
                                Circle()
                                    .fill(Color(.sRGB, white: 0.3, opacity: 0.4))
                                    .overlay(
                                        Circle()
                                            .stroke(Color.white.opacity(0.15), lineWidth: 1.5)
                                    )
                                    .frame(width: 32, height: 32)
                                
                                Image(systemName: "ellipsis")
                                    .font(.system(size: 14, weight: .bold))
                                    .foregroundStyle(Color(.sRGB, white: 0.97, opacity: 1))
                            }
                            .contentShape(Rectangle().size(CGSize(width: 50, height: 50)))
                        }
                        .padding(12) // Increased padding for larger hit area
                        .buttonStyle(.plain)
                        .transition(.opacity)
                    }
                }
            } else {
                Rectangle()
                    .fill(theme.surface)
                    .frame(maxWidth: .infinity)
                    .overlay(
                        ProgressView()
                            .scaleEffect(0.8)
                    )
            }
        }
        .onAppear {
            loadImage()
        }
    }
    
    private func loadImage() {
        guard !imagePath.isEmpty,
              let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return
        }
        
        // First try to get the image from cache
        let cacheKey = "\(documentId)_\(imagePath)"
        if let cachedImage = ImageCache.shared.image(for: cacheKey) {
            image = cachedImage
            return
        }
        
        // If not in cache, load from disk and cache it
        let documentPath = documentsPath.appendingPathComponent(documentId)
        let imagesPath = documentPath.appendingPathComponent("Images")
        let imageUrl = imagesPath.appendingPathComponent(imagePath)
        
        // Load image asynchronously
        DispatchQueue.global(qos: .userInitiated).async {
            if let loadedImage = NSImage(contentsOf: imageUrl) {
                ImageCache.shared.setImage(loadedImage, for: cacheKey)
                
                // Update UI on main thread
                DispatchQueue.main.async {
                    image = loadedImage
                }
            }
        }
    }
    
    private func replaceImage() {
        let panel = NSOpenPanel()
        panel.allowsMultipleSelection = false
        panel.canChooseDirectories = false
        panel.canChooseFiles = true
        panel.allowedContentTypes = [.image]
        
        if panel.runModal() == .OK, let url = panel.url {
            guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
                return
            }
            
            do {
                // Create document image directory if needed
                let documentPath = documentsPath.appendingPathComponent(documentId)
                let imagesPath = documentPath.appendingPathComponent("Images")
                
                if !FileManager.default.fileExists(atPath: imagesPath.path) {
                    try FileManager.default.createDirectory(at: imagesPath, withIntermediateDirectories: true)
                }
                
                // Delete old image if it exists
                let oldImageUrl = imagesPath.appendingPathComponent(imagePath)
                if FileManager.default.fileExists(atPath: oldImageUrl.path) {
                    try FileManager.default.removeItem(at: oldImageUrl)
                }
                
                // Generate a unique filename
                let fileName = "header_\(UUID().uuidString).\(url.pathExtension)"
                let fileURL = imagesPath.appendingPathComponent(fileName)
                
                // Copy the image to the document's image directory
                try FileManager.default.copyItem(at: url, to: fileURL)
                
                // Update document with new image path
                if var headerElement = document.elements.first(where: { $0.type == .headerImage }) {
                    headerElement.content = fileName
                    if let index = document.elements.firstIndex(where: { $0.type == .headerImage }) {
                        document.elements[index] = headerElement
                    }
                } else {
                    let headerElement = DocumentElement(type: .headerImage, content: fileName)
                    document.elements.insert(headerElement, at: 0)
                }
                
                // Save document
                document.save()
                
                // Update image in the UI
                if let newImage = NSImage(contentsOf: fileURL) {
                    ImageCache.shared.setImage(newImage, for: "\(documentId)_\(fileName)")
                    DispatchQueue.main.async {
                        image = newImage
                    }
                }
                
                // Post notification to update document list
                NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
            } catch {
                print("Error handling image: \(error)")
            }
        }
    }
    
    private func downloadImage() {
        guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return
        }
        
        let documentPath = documentsPath.appendingPathComponent(documentId)
        let imagesPath = documentPath.appendingPathComponent("Images")
        let imageUrl = imagesPath.appendingPathComponent(imagePath)
        
        let savePanel = NSSavePanel()
        savePanel.allowedContentTypes = [.image]
        savePanel.nameFieldStringValue = imagePath
        
        if savePanel.runModal() == .OK, let destinationURL = savePanel.url {
            do {
                try FileManager.default.copyItem(at: imageUrl, to: destinationURL)
            } catch {
                print("Error downloading image: \(error)")
            }
        }
    }
    
    private func deleteImage() {
        guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return
        }
        
        do {
            // Remove the image file
            let documentPath = documentsPath.appendingPathComponent(documentId)
            let imagesPath = documentPath.appendingPathComponent("Images")
            let imageUrl = imagesPath.appendingPathComponent(imagePath)
            
            if FileManager.default.fileExists(atPath: imageUrl.path) {
                try FileManager.default.removeItem(at: imageUrl)
            }
            
            // Update document element
            if var headerElement = document.elements.first(where: { $0.type == .headerImage }) {
                headerElement.content = ""
                if let index = document.elements.firstIndex(where: { $0.type == .headerImage }) {
                    document.elements[index] = headerElement
                }
            }
            
            // Save document
            document.save()
            
            // Update UI
            DispatchQueue.main.async {
                image = nil
            }
            
            // Post notification to update document list
            NotificationCenter.default.post(name: NSNotification.Name("DocumentListDidUpdate"), object: nil)
        } catch {
            print("Error deleting image: \(error)")
        }
    }
}

// Add this before the DocumentDetailsCard struct
class SwipeGestureRecognizer: NSGestureRecognizer {
    let onSwipeLeft: () -> Void
    let onSwipeRight: () -> Void
    
    init(target: Any?, onSwipeLeft: @escaping () -> Void, onSwipeRight: @escaping () -> Void) {
        self.onSwipeLeft = onSwipeLeft
        self.onSwipeRight = onSwipeRight
        super.init(target: target, action: nil)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func touchesBegan(with event: NSEvent) {
        super.touchesBegan(with: event)
        self.state = .began
    }
    
    override func touchesMoved(with event: NSEvent) {
        super.touchesMoved(with: event)
        self.state = .changed
    }
    
    override func touchesEnded(with event: NSEvent) {
        super.touchesEnded(with: event)
        
        // We need at least two touches for a swipe
        if event.type == .gesture {
            // Check if this is a swipe gesture
            if event.phase == .ended {
                let translation = event.deltaX
                
                if translation < -50 {
                    onSwipeLeft()
                } else if translation > 50 {
                    onSwipeRight()
                }
            }
        }
        self.state = .ended
    }
    
    override func touchesCancelled(with event: NSEvent) {
        super.touchesCancelled(with: event)
        self.state = .cancelled
    }
}

struct SwipeGestureViewModifier: ViewModifier {
    let onSwipeLeft: () -> Void
    let onSwipeRight: () -> Void
    
    func body(content: Content) -> some View {
        content
            .background(
                SwipeGestureRecognizerView(
                    onSwipeLeft: onSwipeLeft,
                    onSwipeRight: onSwipeRight
                )
            )
    }
}

struct SwipeGestureRecognizerView: NSViewRepresentable {
    let onSwipeLeft: () -> Void
    let onSwipeRight: () -> Void
    
    func makeNSView(context: Context) -> NSView {
        let view = SwipeCaptureView()
        view.onSwipeLeft = onSwipeLeft
        view.onSwipeRight = onSwipeRight
        return view
    }
    
    func updateNSView(_ nsView: NSView, context: Context) {
        if let view = nsView as? SwipeCaptureView {
            view.onSwipeLeft = onSwipeLeft
            view.onSwipeRight = onSwipeRight
        }
    }
    
    // A custom NSView that handles swipe events through touchesMoved rather than gesture recognizers
    class SwipeCaptureView: NSView {
        var onSwipeLeft: (() -> Void)?
        var onSwipeRight: (() -> Void)?
        var startLocation: CGPoint?
        var lastProcessTime = Date()
        let minSwipeDistance: CGFloat = 50
        
        override init(frame frameRect: NSRect) {
            super.init(frame: frameRect)
            self.wantsLayer = true
            self.layer?.backgroundColor = NSColor.clear.cgColor
            self.allowedTouchTypes = [.direct]
            self.wantsRestingTouches = true
        }
        
        required init?(coder: NSCoder) {
            fatalError("init(coder:) has not been implemented")
        }
        
        override func touchesBegan(with event: NSEvent) {
            super.touchesBegan(with: event)
            // Record the start location of the touch
            if let touch = event.allTouches().first {
                startLocation = touch.location(in: self)
            }
        }
        
        override func touchesMoved(with event: NSEvent) {
            super.touchesMoved(with: event)
            // Skip if we're processing too frequently
            let now = Date()
            if now.timeIntervalSince(lastProcessTime) < 0.1 {
                return
            }
            
            // Only process if we have a start location and at least one touch
            guard let start = startLocation,
                  let touch = event.allTouches().first else {
                return
            }
            
            // Get the current touch location
            let currentLocation = touch.location(in: self)
            let deltaX = currentLocation.x - start.x
            
            // Check if we've moved far enough to consider it a swipe
            if abs(deltaX) > minSwipeDistance {
                lastProcessTime = now
                print("Touch-based swipe detected: \(deltaX < 0 ? "LEFT" : "RIGHT")")
                
                if deltaX < 0 {
                    if let action = onSwipeLeft {
                        action()
                    }
                } else {
                    if let action = onSwipeRight {
                        action()
                    }
                }
                
                // Reset the start location to prevent multiple triggers
                startLocation = nil
            }
        }
        
        override func touchesEnded(with event: NSEvent) {
            super.touchesEnded(with: event)
            startLocation = nil
        }
        
        override func touchesCancelled(with event: NSEvent) {
            super.touchesCancelled(with: event)
            startLocation = nil
        }
        
        // Make sure this view can become first responder
        override var acceptsFirstResponder: Bool {
            return true
        }
        
        // Accept all mouse/touch events
        override func hitTest(_ point: NSPoint) -> NSView? {
            return self
        }
        
        // Also handle scroll wheel events as an alternative
        override func scrollWheel(with event: NSEvent) {
            // Don't call super to capture the event
            
            // Detect horizontal scrolling
            let deltaX = event.scrollingDeltaX
            print("Scroll wheel event: deltaX=\(deltaX)")
            
            // Protect against rapid successive events
            let now = Date()
            if now.timeIntervalSince(lastProcessTime) < 0.1 {
                return
            }
            
            // Process scroll events
            if abs(deltaX) > 20 {
                lastProcessTime = now
                
                if deltaX > 0 {
                    print("Scroll detected: LEFT")
                    if let action = onSwipeLeft {
                        action()
                    }
                } else {
                    print("Scroll detected: RIGHT")
                    if let action = onSwipeRight {
                        action()
                    }
                }
                
                // Provide haptic feedback if available
                NSHapticFeedbackManager.defaultPerformer.perform(.generic, performanceTime: .default)
            }
        }
    }
}

extension View {
    func onSwipeGesture(onSwipeLeft: @escaping () -> Void, onSwipeRight: @escaping () -> Void) -> some View {
        self.modifier(SwipeGestureViewModifier(onSwipeLeft: onSwipeLeft, onSwipeRight: onSwipeRight))
    }
}

extension View {
    func trackpadSwipe(onSwipeLeft: @escaping () -> Void, onSwipeRight: @escaping () -> Void) -> some View {
        self.gesture(
            DragGesture(minimumDistance: 20, coordinateSpace: .local)
                .onEnded { value in
                    let horizontalAmount = value.translation.width
                    // Use predictedEndTranslation to estimate velocity
                    let predictedMovement = value.predictedEndTranslation.width - horizontalAmount
                    
                    // Print debug info to help diagnose issues
                    print("Drag detected: \(horizontalAmount), predicted movement: \(predictedMovement)")
                    
                    // Check if it's likely a two-finger swipe
                    if abs(horizontalAmount) > 20 && abs(predictedMovement) > 10 {
                        if horizontalAmount < 0 {
                            onSwipeLeft()
                            // Use proper haptic feedback API
                            NSHapticFeedbackManager.defaultPerformer.perform(.generic, performanceTime: .default)
                        } else {
                            onSwipeRight()
                            // Use proper haptic feedback API
                            NSHapticFeedbackManager.defaultPerformer.perform(.generic, performanceTime: .default)
                        }
                    }
                }
        )
    }
}

// Add this before the DocumentDetailsCard struct
struct TrackpadScrollModifier: ViewModifier {
    let onScrollLeft: () -> Void
    let onScrollRight: () -> Void
    
    // SwiftUI doesn't directly expose scroll events, so we need to use an NSViewRepresentable
    struct ScrollEventView: NSViewRepresentable {
        let onScrollLeft: () -> Void
        let onScrollRight: () -> Void
        
        func makeNSView(context: Context) -> NSView {
            let view = TrackpadScrollView()
            view.onScrollLeft = onScrollLeft
            view.onScrollRight = onScrollRight
            return view
        }
        
        func updateNSView(_ nsView: NSView, context: Context) {
            if let view = nsView as? TrackpadScrollView {
                view.onScrollLeft = onScrollLeft
                view.onScrollRight = onScrollRight
            }
        }
    }
    
    // Custom NSView that detects scroll events
    class TrackpadScrollView: NSView {
        var onScrollLeft: (() -> Void)?
        var onScrollRight: (() -> Void)?
        var lastScrollTime: Date = Date()
        let scrollThreshold: CGFloat = 15 // Lower threshold for better sensitivity
        
        
        override init(frame frameRect: NSRect) {
            super.init(frame: frameRect)
            self.wantsLayer = true
            self.layer?.backgroundColor = NSColor.clear.cgColor
            self.allowedTouchTypes = [.direct]
            self.wantsRestingTouches = true
        }
        
        required init?(coder: NSCoder) {
            fatalError("init(coder:) has not been implemented")
        }
        
        override func scrollWheel(with event: NSEvent) {
            // Don't call super to capture the event
            
            // Detect horizontal scrolling
            let deltaX = event.scrollingDeltaX
            print("Scroll wheel event: deltaX=\(deltaX)")
            
            // Protect against rapid successive events
            let now = Date()
            if now.timeIntervalSince(lastScrollTime) < 0.1 {
                return
            }
            
            // Process scroll events
            if abs(deltaX) > scrollThreshold {
                lastScrollTime = now
                
                if deltaX > 0 {
                    print("Scroll detected: LEFT")
                    if let action = onScrollLeft {
                        action()
                    }
                } else {
                    print("Scroll detected: RIGHT")
                    if let action = onScrollRight {
                        action()
                    }
                }
                
                // Provide haptic feedback if available
                NSHapticFeedbackManager.defaultPerformer.perform(.generic, performanceTime: .default)
            }
        }
        
        // Make sure this view can become first responder
        override var acceptsFirstResponder: Bool {
            return true
        }
        
        // Accept all mouse/touch events
        override func hitTest(_ point: NSPoint) -> NSView? {
            return self
        }
    }
    
    func body(content: Content) -> some View {
        content.background(
            ScrollEventView(
                onScrollLeft: onScrollLeft,
                onScrollRight: onScrollRight
            )
        )
    }
}

extension View {
    func onTrackpadScroll(onScrollLeft: @escaping () -> Void, onScrollRight: @escaping () -> Void) -> some View {
        self.modifier(TrackpadScrollModifier(onScrollLeft: onScrollLeft, onScrollRight: onScrollRight))
    }
}

// Month/year picker view for calendar
private struct MonthYearPickerView: View {
    @Binding var selectedMonth: Int
    @Binding var selectedYear: Int
    let onDismiss: () -> Void
    @Environment(\.themeColors) var theme
    @Environment(\.colorScheme) var colorScheme
    @State private var hoveredMonth: Int? = nil  // Add state for hovered month
    
    var body: some View {
        // Use a ZStack with a white background that extends to the edges
        ZStack {
            // Background layer
            Rectangle()
                .fill(colorScheme == .dark ? Color(.sRGB, white: 0.12) : .white)
                .edgesIgnoringSafeArea(.all)
            
            // Content layer
            VStack(spacing: 6) {  // Further reduced from 8 to 6
                // Year with navigation
                HStack {
                    Button(action: {
                        selectedYear -= 1
                    }) {
                        ZStack {
                            Circle()
                                .fill(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97))
                                .frame(width: 22, height: 22)  // Further reduced from 24x24 to 22x22
                            
                            Image(systemName: "chevron.left")
                                .font(.system(size: 9))  // Further reduced from 10 to 9
                                .foregroundStyle(theme.secondary)
                        }
                    }
                    .buttonStyle(.plain)
                    
                    Spacer()
                    
                    Text(verbatim: "\(selectedYear)")
                        .font(.system(size: 15, weight: .medium))  // Further reduced from 16 to 15
                        .foregroundStyle(theme.primary)
                    
                    Spacer()
                    
                    Button(action: {
                        selectedYear += 1
                    }) {
                        ZStack {
                            Circle()
                                .fill(colorScheme == .dark ? Color(.sRGB, white: 0.2) : Color(.sRGB, white: 0.97))
                                .frame(width: 22, height: 22)  // Further reduced from 24x24 to 22x22
                            
                            Image(systemName: "chevron.right")
                                .font(.system(size: 9))  // Further reduced from 10 to 9
                                .foregroundStyle(theme.secondary)
                        }
                    }
                    .buttonStyle(.plain)
                }
                
                // Month grid
                LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 4), spacing: 6) {  // Further reduced from 8 to 6
                    ForEach(1...12, id: \.self) { month in
                        Button(action: {
                            selectedMonth = month
                            onDismiss()
                        }) {
                            Text(Calendar.current.shortMonthSymbols[month-1])
                                .font(.system(size: 11))  // Further reduced from 12 to 11
                                .frame(height: 24)  // Further reduced from 26 to 24
                                .frame(maxWidth: .infinity)
                                .background(
                                    RoundedRectangle(cornerRadius: 5)  // Further reduced from 6 to 5
                                        .fill(
                                            selectedMonth == month ? theme.accent.opacity(0.15) :
                                            hoveredMonth == month ? theme.accent.opacity(0.05) :
                                            Color.clear
                                        )
                                        .overlay(
                                            RoundedRectangle(cornerRadius: 5)  // Further reduced from 6 to 5
                                                .stroke(selectedMonth == month ? 
                                                       theme.accent : 
                                                       Color.clear, lineWidth: 0.8)  // Further reduced from 1 to 0.8
                                        )
                                )
                                .foregroundStyle(selectedMonth == month ? theme.accent : theme.primary)
                        }
                        .buttonStyle(.plain)
                        .onHover { isHovered in
                            hoveredMonth = isHovered ? month : nil
                        }
                    }
                }
                
                Divider()
                
                // Bottom controls
                HStack {
                    Button("Today") {
                        let today = Date()
                        selectedMonth = Calendar.current.component(.month, from: today)
                        selectedYear = Calendar.current.component(.year, from: today)
                        onDismiss()
                    }
                    .buttonStyle(.plain)
                    .font(.system(size: 11))  // Further reduced from 12 to 11
                    .foregroundStyle(theme.accent)
                    
                    Spacer()
                    
                    Button("Cancel") {
                        onDismiss()
                    }
                    .buttonStyle(.plain)
                    .font(.system(size: 11))  // Further reduced from 12 to 11
                    .foregroundStyle(theme.secondary)
                }
            }
            .padding(10)  // Further reduced from 12 to 10
        }
        .frame(width: 200)  // Further reduced from 220 to 200
    }
}

// Remove the crashing extension
// extension View {
//     func customPopoverStyle() -> some View {
//         ...
//     }
// }

